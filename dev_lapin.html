<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestionnaire de Stock - Cuves</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen bg-gray-50 p-4" style="font-size: 16px;">
    <div id="mainApp">
        <div class="max-w-6xl mx-auto">
            <h1 class="text-3xl font-bold text-center mb-6 text-blue-600">
                📦 Gestionnaire de Stock - Cuves
            </h1>

            <!-- Custom Popup -->
            <div id="popup" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 relative">
                    <div id="popupIcon" class="text-4xl mb-4 text-center"></div>
                    <div id="popupTitle" class="text-xl font-bold mb-2 text-center"></div>
                    <div id="popupMessage" class="text-gray-600 mb-6 text-center whitespace-pre-line"></div>
                    <div class="flex justify-center gap-3">
                        <button 
                            id="popupConfirmBtn"
                            class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg font-medium"
                        >
                            OK
                        </button>
                        <button 
                            id="popupCancelBtn"
                            class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg font-medium hidden"
                        >
                            Annuler
                        </button>
                    </div>
                </div>
            </div>

            <!-- Navigation -->
            <div class="flex mb-6 bg-white rounded-lg shadow p-2">
                <button
                    id="addTab"
                    onclick="setActiveTab('add')"
                    class="flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white"
                >
                    ➕ Ajouter
                </button>
                <button
                    id="stockTab"
                    onclick="setActiveTab('stock')"
                    class="flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100"
                >
                    📊 Stock (<span id="stockCount">0</span>)
                </button>
            </div>

            <!-- Add Tab -->
            <div id="addTabContent" class="bg-white rounded-lg shadow p-2">
                <h2 class="text-2xl font-bold mb-6">Ajouter des cuves</h2>
                
                <div class="bg-white rounded-lg shadow p-6 max-w-4xl mx-auto">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                        <div class="flex flex-col gap-0">
                            <!-- Code ou Nom Client -->
                            <label class="block text-lg font-bold text-gray-700 mb-2">Code ou Nom Client</label>
                            <input
                                type="text"
                                id="clientCode"
                                class="w-full p-4 border-2 border-gray-300 rounded-xl text-2xl mb-3"
                                placeholder="Ex : 199, BEAUNES, 5000, CARON..."
                                autocomplete="off"
                                oninput="showClientSuggestions()"
                            />
                            <div id="clientSuggestions" class="absolute z-50 bg-white border border-gray-300 rounded-lg shadow-lg mt-1 w-full hidden"></div>
                            <!-- Date et Heure de Chargement -->
                            <label for="loadingDateTime" class="block text-lg font-bold text-gray-700 mb-2 mt-2">Date et Heure de Chargement</label>
                            <input
                                type="text"
                                id="loadingDateTime"
                                class="w-full p-4 border-2 border-gray-300 rounded-xl text-2xl mb-3"
                                placeholder="JJ/MM HHh"
                                maxlength="9"
                                autocomplete="off"
                                inputmode="numeric"
                            />
                            <!-- ID Cuve (rapide) -->
                            <label class="block text-lg font-bold text-gray-700 mb-2 mt-2">ID Cuve (rapide)</label>
                            <input
                                type="text"
                                id="quickCuveId"
                                class="w-full p-4 border-2 border-gray-300 rounded-xl text-2xl mb-3"
                                placeholder="ID Cuve unique"
                                autocomplete="off"
                            />
                            <div id="quickCuveIdSuggestions" class="absolute z-50 bg-white border border-gray-300 rounded-lg shadow-lg mt-1 w-full hidden"></div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">
                                Nombre de cuves (optionnel)
                            </label>
                            <input
                                type="number"
                                id="quantity"
                                class="w-full p-3 border-2 border-gray-300 rounded-lg text-lg"
                                placeholder="Laisser vide si inconnu"
                                min="1"
                                max="22"
                                onchange="updateCuveIdFields()"
                            />
                            <div class="text-sm text-gray-500 mt-1">
                                💡 Si vide, la quantité sera calculée automatiquement selon les lignes sélectionnées
                            </div>
                            <!-- Début zone Chargement camion -->
                            <div id="truckLoadingSection" class="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                <div class="font-bold text-lg mb-2">🚚 Chargement camion</div>
                                <div id="truckLoadingList"></div>
                                <button id="addTruckLoadingClientBtn" class="mt-2 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded font-bold text-base">Ajouter un client à charger</button>
                                <button id="truckLoadingFinishBtn" class="mt-2 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-bold text-base">Chargement fini</button>
                            </div>
                            <!-- Fin zone Chargement camion -->
                            <div id="cuveIdFields" class="mt-4">
                                <!-- Cuve ID fields will be generated here -->
                            </div>
                        </div>
                    </div>
                    <div id="groupingInfo"></div>
                    <div class="mb-8">
                        <label class="block text-xl font-bold text-gray-700 mb-4">Nouveau frigo</label>
                        <div id="linesGrid" class="flex flex-row gap-2 mb-4 overflow-x-auto">
                            <!-- Lines 1-14 as a single row of small squares -->
                        </div>
                        <div class="mb-4 text-sm">
                            <div class="flex items-center gap-4 flex-wrap">
                                <div class="flex items-center gap-1">
                                    <div class="w-4 h-4 bg-gray-200 rounded"></div>
                                    <span>Libre</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <div class="w-4 h-4 bg-green-500 rounded"></div>
                                    <span>Sélectionnée</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <div class="w-4 h-4 bg-orange-200 border border-orange-500 rounded"></div>
                                    <span>Suggérée</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <div class="w-4 h-4 bg-red-500 rounded"></div>
                                    <span>Occupée</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex flex-col md:flex-row gap-2 mb-2">
                            <button
                                onclick="addStock()"
                                class="w-full md:w-auto bg-green-500 hover:bg-green-600 text-white py-3 px-6 rounded-lg font-bold text-lg"
                            >
                                ✅ Ajouter au stock
                            </button>
                            <button
                                onclick="completeRow()"
                                class="w-full md:w-auto bg-blue-500 hover:bg-blue-600 text-white py-3 px-6 rounded-lg font-bold text-lg"
                                title="Compléter automatiquement la ligne selon la quantité prévue"
                            >
                                🤖 Compléter une ligne
                            </button>
                            <button
                                onclick="showMoveLinePopup()"
                                class="w-full md:w-auto bg-yellow-500 hover:bg-yellow-600 text-white py-3 px-6 rounded-lg font-bold text-lg"
                                title="Déplacer une ligne de cuves pour un client"
                            >
                                🔄 Déplacer une ligne
                            </button>
                        </div>
                        <div class="text-xs text-gray-500 mb-2">
                            • Si une quantité est renseignée, cliquez sur <b>Compléter une ligne</b> pour que le système suggère automatiquement la meilleure ligne.<br>
                            • Sinon, sélectionnez manuellement une ou plusieurs lignes.<br>
                            <span class="inline-flex items-center"><span class="w-4 h-4 bg-red-500 inline-block rounded mr-1"></span> Ligne à risque FIFO (un tank plus ancien est derrière)</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Stock Tab -->
            <div id="stockTabContent" class="bg-white rounded-lg shadow p-6 hidden">
                <div class="mb-6">
                    <label class="block text-xl font-bold text-gray-700 mb-2">Nouveau frigo</label>
                    <div id="stockNouveauFrigoGrid" class="flex flex-row gap-2 mb-4 overflow-x-auto"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==============================================
        // Constants and State Variables
        // ==============================================
        const clients = {
            '199': 'Beaunes',
            '5000': 'Barilla T3',
            '5003': 'Barilla T4',
            '260': 'Viennoise Ligérienne',
            '276': 'Brioche Cop',
            '122': 'Brioche Heber',
            '9': 'Brioche Fonteneau'
        };

        const lines = Array.from({ length: 14 }, (_, i) => i + 1);

        // Global state variables
        let activeTab = 'add';
        let stockEntries = [];
        let clientCode = '';
        let quantity = '';
        let dateTime = '';
        let selectedLines = [];
        let cuveIds = [];
        let currentUser = '';
        let highlightedLines = [];
        let highlightedClientLines = [];

        // Palette de couleurs pour clients (7 couleurs)
        const CLIENT_COLORS = [
            '#60a5fa', // bleu
            '#34d399', // vert
            '#fbbf24', // jaune
            '#f87171', // rouge
            '#a78bfa', // violet
            '#f472b6', // rose
            '#38bdf8'  // cyan
        ];

        function getClientColor(clientCode, clientCodesInLine) {
            const idx = clientCodesInLine.indexOf(clientCode);
            return CLIENT_COLORS[idx % CLIENT_COLORS.length];
        }

        // ==============================================
        // Date Handling Utilities
        // ==============================================
        
        function parseDateTime(dt) {
            // Expects format DD/MM HHh
            const match = dt.match(/(\d{2})\/(\d{2}) (\d{2})h/);
            if (!match) return null;
            const now = new Date();
            // Use current year for context
            return new Date(now.getFullYear(), parseInt(match[2], 10) - 1, parseInt(match[1], 10), parseInt(match[3], 10), 0, 0, 0);
        }

        function formatDateFr(date) {
            if (!date || !(date instanceof Date) || isNaN(date)) {
                if (typeof date === 'string') {
                    const parsedDate = parseDateTime(date);
                    if (parsedDate) {
                        return formatDateFr(parsedDate);
                    }
                }
                return 'Date invalide';
            }
            
            const addZero = (n) => n < 10 ? `0${n}` : n;
            
            const day = addZero(date.getDate());
            const month = addZero(date.getMonth() + 1);
            const hours = addZero(date.getHours());
            
            const result = `${day}/${month} ${hours}h`;
            return result;
        }

        // ==============================================
        // Search and Filter Functions
        // ==============================================
        
        function showClientSuggestions() {
            const input = document.getElementById('clientCode');
            const suggestionsDiv = document.getElementById('clientSuggestions');
            const value = input.value.trim().toUpperCase();
            if (!value) {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.add('hidden');
                return;
            }

            let suggestions = [];
            Object.entries(clients).forEach(([code, name]) => {
                if (code.toUpperCase().includes(value) || name.toUpperCase().includes(value)) {
                    suggestions.push({ code, name });
                }
            });

            if (suggestions.length > 0) {
                suggestionsDiv.innerHTML = `<div style='text-align:center; font-size:18px; color:#60a5fa; margin-bottom:-6px;'>▼</div>` +
                    suggestions.map(s => `<div class='px-4 py-2 hover:bg-blue-100 cursor-pointer' data-code='${s.code}' data-name='${s.name}'><b>${s.code}</b> - <b>${s.name}</b></div>`).join('');
                suggestionsDiv.classList.remove('hidden');
                
                const rect = input.getBoundingClientRect();
                suggestionsDiv.style.position = 'fixed';
                suggestionsDiv.style.left = rect.left + 'px';
                suggestionsDiv.style.width = rect.width + 'px';
                suggestionsDiv.style.top = (rect.top - suggestionsDiv.offsetHeight - 8) + 'px';
                suggestionsDiv.style.bottom = 'auto';
                suggestionsDiv.style.zIndex = 1000;
                suggestionsDiv.style.background = 'white';
                suggestionsDiv.style.borderRadius = '0.5rem';
                suggestionsDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.08)';
                suggestionsDiv.style.border = '1px solid #d1d5db';
                suggestionsDiv.style.paddingTop = '0.25rem';
            } else {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.add('hidden');
            }

            suggestionsDiv.onclick = function(e) {
                let target = e.target;
                while (target && !target.dataset.code && target !== suggestionsDiv) {
                    target = target.parentElement;
                }
                if (target && target.dataset && target.dataset.code) {
                    input.value = `${target.dataset.code} ${target.dataset.name}`;
                    clientCode = `${target.dataset.code} ${target.dataset.name}`;
                    suggestionsDiv.classList.add('hidden');
                    updateGroupingInfo();
                    updateLinesGrid();
                    setTimeout(() => {
                        const dt = document.getElementById('loadingDateTime');
                        if (dt) dt.focus();
                    }, 0);
                }
            };

            input.onblur = function() {
                setTimeout(() => suggestionsDiv.classList.add('hidden'), 150);
            };
            input.onfocus = function() {
                if (suggestionsDiv.innerHTML) suggestionsDiv.classList.remove('hidden');
            };
        }

        // ==============================================
        // Event Listeners and Initialization
        // ==============================================
        
        document.addEventListener('DOMContentLoaded', function() {
            const now = new Date();
            const formatted = now.toISOString().slice(0, 16);
            dateTime = formatted;
            
            generateLinesGrid();
            updateLinesGrid();

            document.getElementById('clientCode').addEventListener('input', function(e) {
                clientCode = e.target.value.toUpperCase();
                e.target.value = clientCode;
                updateGroupingInfo();
                updateLinesGrid();
            });

            document.getElementById('quantity').addEventListener('input', function(e) {
                quantity = e.target.value;
                updateLinesGrid();
            });

            const loadingDateTimeInput = document.getElementById('loadingDateTime');
            if (loadingDateTimeInput) {
                loadingDateTimeInput.addEventListener('input', function(e) {
                    let v = e.target.value.replace(/[^0-9]/g, '');
                    let out = '';
                    if (v.length > 0) out += v.substring(0, 2);
                    if (v.length >= 2) out += '/';
                    if (v.length > 2) out += v.substring(2, 4);
                    if (v.length >= 4) out += ' ';
                    if (v.length > 4) out += v.substring(4, 6);
                    if (v.length >= 6) out += 'h';
                    e.target.value = out;
                    // Ajout du focus automatique
                    if (out.length === 9) {
                        const quickCuveIdInput = document.getElementById('quickCuveId');
                        if (quickCuveIdInput) quickCuveIdInput.focus();
                    }
                    dateTime = out;  // Update the dateTime variable
                    updateGroupingInfo();  // Update UI to reflect the new date
                    updateLinesGrid();
                });

                loadingDateTimeInput.addEventListener('keydown', function(e) {
                    if (!((e.key >= '0' && e.key <= '9') || ['Backspace','Delete','ArrowLeft','ArrowRight','Tab'].includes(e.key))) {
                        e.preventDefault();
                    }
                });
                loadingDateTimeInput.setAttribute('maxlength', '9');
            }

            // Attach client code input event
            const clientCodeInput = document.getElementById('clientCode');
            if (clientCodeInput) {
                clientCodeInput.removeEventListener('input', showClientSuggestions);
                clientCodeInput.addEventListener('input', showClientSuggestions);
            }

            // Attacher l'événement du bouton 'Chargement fini' ici
            const truckLoadingFinishBtn = document.getElementById('truckLoadingFinishBtn');
            if (truckLoadingFinishBtn) {
                truckLoadingFinishBtn.onclick = async function() {
                    if (!window.truckLoadingData || !window.truckLoadingData.length) {
                        await showPopup({
                            title: 'Erreur',
                            message: 'Aucun client sélectionné pour le chargement.',
                            icon: '⚠️'
                        });
                        return;
                    }
                    // Confirmation
                    const confirmed = await showPopup({
                        title: 'Confirmer le chargement',
                        message: 'Voulez-vous supprimer toutes les cuves des clients sélectionnés du stock ?',
                        icon: '🚚',
                        confirmText: 'Oui, supprimer',
                        cancelText: 'Annuler',
                        showCancel: true
                    });
                    if (!confirmed) return;

                    // Pour chaque client/date sélectionné, supprimer les cuves du stock
                    window.truckLoadingData.forEach(item => {
                        if (!item.clientCode || !item.dateTime) return;
                        stockEntries = stockEntries.filter(e =>
                            !(e.clientCode === item.clientCode && e.dateTime === item.dateTime)
                        );
                    });

                    // Vide la liste de chargement camion
                    window.truckLoadingData = [];
                    renderTruckLoadingList();

                    // Met à jour l'affichage et sauvegarde
                    updateStockViewAndSave();

                    await showPopup({
                        title: 'Succès',
                        message: 'Les cuves des clients sélectionnés ont été supprimées du stock.',
                        icon: '✅'
                    });
                };
            }

            // Ajout du bouton 'Supprimer une ligne' dans Ajouter
            const addTabContent = document.getElementById('addTabContent');
            if (addTabContent && !document.getElementById('deleteLineBtnAdd')) {
                const deleteLineBtnAdd = document.createElement('button');
                deleteLineBtnAdd.id = 'deleteLineBtnAdd';
                deleteLineBtnAdd.className = 'mb-4 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-bold text-base w-full';
                deleteLineBtnAdd.innerText = "Supprimer toutes les cuves d'une ligne";
                addTabContent.insertBefore(deleteLineBtnAdd, addTabContent.firstChild);
                deleteLineBtnAdd.onclick = showDeleteLinePopup;
            }
            // Ajout du bouton 'Supprimer une ligne' dans Stock
            const stockTabContent = document.getElementById('stockTabContent');
            if (stockTabContent && !document.getElementById('deleteLineBtn')) {
                const deleteLineBtn = document.createElement('button');
                deleteLineBtn.id = 'deleteLineBtn';
                deleteLineBtn.className = 'mb-4 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-bold text-base w-full';
                deleteLineBtn.innerText = "Supprimer toutes les cuves d'une ligne";
                stockTabContent.insertBefore(deleteLineBtn, stockTabContent.firstChild);
                deleteLineBtn.onclick = showDeleteLinePopup;
            }

            // 1. SUPPRIME les anciens boutons en haut
            const oldDeleteBtnAdd = document.getElementById('deleteLineBtnAdd');
            if (oldDeleteBtnAdd) oldDeleteBtnAdd.remove();
            const oldDeleteBtnStock = document.getElementById('deleteLineBtn');
            if (oldDeleteBtnStock) oldDeleteBtnStock.remove();
            // 2. Ajoute le petit bouton dans Ajouter, à droite de 'Déplacer une ligne'
            const addBtnRow = document.querySelector('#addTabContent .flex.flex-col.md\\:flex-row.gap-2.mb-2');
            if (addBtnRow && !document.getElementById('deleteLineBtnAddMini')) {
                const deleteBtn = document.createElement('button');
                deleteBtn.id = 'deleteLineBtnAddMini';
                deleteBtn.className = 'w-12 h-12 flex items-center justify-center rounded-lg font-bold text-lg border-2 cursor-pointer bg-red-500 hover:bg-red-600 text-white shadow';
                deleteBtn.title = 'Supprimer une ligne';
                deleteBtn.innerHTML = '🗑️';
                addBtnRow.appendChild(deleteBtn);
                deleteBtn.onclick = showDeleteLinePopup;
            }

            // Ajout du formulaire d'ajout de client en haut de l'onglet Stock
            const stockTabContentAddClient = document.getElementById('stockTabContent');
            if (stockTabContentAddClient && !document.getElementById('addClientForm')) {
                const addClientDiv = document.createElement('div');
                addClientDiv.id = 'addClientForm';
                addClientDiv.className = 'mb-6 p-4 bg-blue-50 border border-blue-200 rounded flex flex-col md:flex-row gap-2 items-center';
                addClientDiv.innerHTML = `
                    <input id='newClientCode' type='text' maxlength='10' placeholder='Code client' class='p-2 border rounded w-32' />
                    <input id='newClientName' type='text' maxlength='40' placeholder='Nom client' class='p-2 border rounded flex-1' />
                    <button id='addClientBtn' class='bg-blue-600 hover:bg-blue-700 text-white font-bold px-4 py-2 rounded'>Ajouter</button>
                    <span id='addClientMsg' class='text-sm ml-2'></span>
                    <div id='clientList' class='w-full mt-4'></div>
                `;
                stockTabContentAddClient.insertBefore(addClientDiv, stockTabContentAddClient.firstChild);
                document.getElementById('addClientBtn').onclick = async function() {
                    const code = document.getElementById('newClientCode').value.trim();
                    const name = document.getElementById('newClientName').value.trim();
                    const msg = document.getElementById('addClientMsg');
                    if (!code || !name) {
                        msg.textContent = 'Code et nom obligatoires';
                        msg.style.color = 'red';
                        return;
                    }
                    if (clients[code]) {
                        msg.textContent = 'Ce code existe déjà';
                        msg.style.color = 'red';
                        return;
                    }
                    const confirmed = await showPopup({
                        title: 'Confirmer l\'ajout',
                        message: `Ajouter le client : ${code} - ${name} ?`,
                        icon: '👤',
                        confirmText: 'Oui, ajouter',
                        cancelText: 'Annuler',
                        showCancel: true
                    });
                    if (!confirmed) return;
                    clients[code] = name;
                    saveClientsToLocal();
                    msg.textContent = 'Client ajouté !';
                    msg.style.color = 'green';
                    document.getElementById('newClientCode').value = '';
                    document.getElementById('newClientName').value = '';
                    setTimeout(()=>{msg.textContent='';}, 2000);
                    renderClientList();
                };
            }
            function renderClientList() {
                const listDiv = document.getElementById('clientList');
                if (!listDiv) return;
                const clientArr = Object.entries(clients);
                const cols = Math.ceil(clientArr.length / 12);
                let html = '<div class="flex flex-row flex-wrap gap-4">';
                for (let c = 0; c < cols; c++) {
                    html += '<div class="flex flex-col gap-1">';
                    for (let i = c * 12; i < Math.min((c + 1) * 12, clientArr.length); i++) {
                        const [code, name] = clientArr[i];
                        html += `<div class='flex items-center gap-2 mb-1'><span class='font-mono bg-gray-100 px-2 py-1 rounded'>${code}</span> <span>${name}</span> <button class='bg-red-500 hover:bg-red-700 text-white rounded px-2 py-1 text-xs' onclick='window.deleteClientFromList("${code}")'>Supprimer</button></div>`;
                    }
                    html += '</div>';
                }
                html += '</div>';
                listDiv.innerHTML = html;
            }
            window.deleteClientFromList = async function(code) {
                const confirmed = await showPopup({
                    title: 'Supprimer le client',
                    message: `Supprimer le client ${code} ?`,
                    icon: '🗑️',
                    confirmText: 'Oui, supprimer',
                    cancelText: 'Annuler',
                    showCancel: true
                });
                if (!confirmed) return;
                delete clients[code];
                saveClientsToLocal();
                renderClientList();
            };
            renderClientList();
        });

        function setActiveTab(tab) {
            activeTab = tab;
            if (tab === 'add') {
                document.getElementById('addTab').className = 'flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white';
                document.getElementById('stockTab').className = 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
                document.getElementById('addTabContent').classList.remove('hidden');
                document.getElementById('stockTabContent').classList.add('hidden');
            } else {
                document.getElementById('addTab').className = 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
                document.getElementById('stockTab').className = 'flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white';
                document.getElementById('addTabContent').classList.add('hidden');
                document.getElementById('stockTabContent').classList.remove('hidden');
                updateStockView();
            }
            document.getElementById('loadingTabContent').classList.toggle('hidden', tab !== 'loading');
            document.getElementById('loadingTab').className = tab === 'loading'
                ? 'flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white'
                : 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
            if (tab === 'loading') updateLoadingList();
        }

        function updateStockFrigoUI() {
            // Nouveau frigo boxes (14 lines, same style as ajout de cuves)
            const stockLinesView = document.getElementById('stockLinesView');
            stockLinesView.innerHTML = '';
            for (let line = 1; line <= 14; line++) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'w-12 h-12 flex flex-col items-center justify-center rounded-lg font-bold text-lg border-2 cursor-pointer bg-white shadow mr-2';
                btn.innerText = line;
                // Show tanks info for this line
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(line));
                if (entries.length > 0) {
                    btn.innerHTML += `<div class='text-xs text-gray-700 mt-1'>${entries.map(e => (e.cuveIds ? e.cuveIds.join(', ') : '')).join('<br>')}</div>`;
                }
                stockLinesView.appendChild(btn);
            }
            renderFrigoLineDetails();
        }

        function showFrigoLineDetails(frigo, line) {
            let entries = stockEntries.filter(e => e.lines && e.lines.includes(line));
            // Highlight selected line in UI (optional)
            // ...
        }

        function renderFrigoLineDetails() {
            const container = document.getElementById('frigoLineDetails');
            let html = '<h4 class="font-bold mb-2">Détails des lignes</h4>';
            html += '<div class="grid grid-cols-1 md:grid-cols-2 gap-4">';
            for (let line = 1; line <= 14; line++) {
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(line));
                html += `<div class="p-3 bg-white rounded shadow border"><b>Ligne ${line}</b><br>`;
                if (entries.length === 0) {
                    html += '<span class="text-gray-500">Aucune cuve</span>';
                } else {
                    entries.forEach(e => {
                        html += `<div class="text-sm">Cuves: ${e.cuveIds ? e.cuveIds.join(', ') : ''}<br>Client: ${e.clientName || ''}<br>Date/Heure: ${e.dateTime || ''}</div>`;
                    });
                }
                html += '</div>';
            }
            html += '</div>';
            container.innerHTML = html;
        }

        function addToClientCode(char) {
            clientCode += char;
            document.getElementById('clientCode').value = clientCode;
            updateGroupingInfo();
            updateLinesGrid();
        }

        function clearClientCode() {
            clientCode = '';
            document.getElementById('clientCode').value = clientCode;
            updateGroupingInfo();
            updateLinesGrid();
        }

        function backspaceClientCode() {
            clientCode = clientCode.slice(0, -1);
            document.getElementById('clientCode').value = clientCode;
            updateGroupingInfo();
            updateLinesGrid();
        }

        function getClientInfo(input) {
            if (!input) return null;
            
            // Recherche par code exact
            const clientByCode = clients[input];
            if (clientByCode) return { code: input, name: clientByCode };
            
            // Recherche par nom (partiel)
            for (const [code, name] of Object.entries(clients)) {
                if (name.toUpperCase().includes(input.toUpperCase()) || 
                    input.toUpperCase().includes(name.toUpperCase())) {
                    return { code, name };
                }
            }
            
            return null;
        }

        function updateGroupingInfo() {
            const clientInfo = getClientInfo(clientCode);
            const groupingInfoDiv = document.getElementById('groupingInfo');
            if (!clientInfo) {
                groupingInfoDiv.innerHTML = '';
                return;
            }
            const existingCuves = stockEntries.filter(entry => 
                entry.clientCode === clientInfo.code && entry.dateTime === dateTime
            );
            let html = '';
            if (existingCuves.length > 0) {
                const totalQuantity = existingCuves.reduce((sum, entry) => sum + entry.quantity, 0);
                const existingLines = existingCuves.flatMap(entry => entry.lines).sort((a,b) => a-b);
                html += `
                    <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                        <p class="text-blue-800 font-medium">
                            ℹ️ ${totalQuantity} cuves déjà en stock pour ce client/date/heure.<br />
                            Lignes : ${existingLines.join(', ')}
                        </p>
                    </div>
                `;
            }
            const suggestions = getSuggestedLines();
            if (suggestions.length > 0) {
                const quantity = parseInt(document.getElementById('quantity').value) || 1;
                const batchDate = new Date(dateTime);
                const distribution = suggestions.map(line => {
                    const info = getLineInfo(line);
                    // Find earliest and latest date in this line
                    const entries = stockEntries.filter(entry => entry.lines.includes(line));
                    let placement = '';
                    if (entries.length > 0) {
                        const dates = entries.map(e => new Date(e.dateTime));
                        const minDate = new Date(Math.min(...dates));
                        const maxDate = new Date(Math.max(...dates));
                        if (batchDate < minDate) {
                            placement = '<span class="text-green-700 font-bold">(avant - devant)</span>';
                        } else if (batchDate > maxDate) {
                            placement = '<span class="text-blue-700 font-bold">(arrière - fond)</span>';
                        } else {
                            placement = '<span class="text-orange-700 font-bold">(au milieu)</span>';
                        }
                    } else {
                        placement = '<span class="text-gray-700">(ligne vide)</span>';
                    }
                    const clientDetails = entries.length > 0 ? 
                        ` - Contient: ${entries.map(e => `${e.clientName} (${e.quantity})`).join(', ')}` : 
                        ' - Vide';
                    return `Ligne ${line}: ${22 - info.quantity} places disponibles${clientDetails} ${placement}`;
                }).join('<br>');
                html += `
                    <div class="mb-4 p-3 bg-orange-50 border border-orange-200 rounded-lg">
                        <p class="text-orange-800 font-medium mb-2">
                            💡 Suggestion d'optimisation pour ${quantity} cuves:<br>
                            ${distribution}
                        </p>
                        <div class="mb-2">
                        <button
                            onclick="useSuggestion()"
                            class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded font-medium"
                        >
                            Utiliser suggestion
                        </button>
                        </div>
                    </div>
                `;
            }
            groupingInfoDiv.innerHTML = html;
        }

        function getSuggestedLines() {
            const clientInfo = getClientInfo(clientCode);
            if (!clientInfo) return [];

            const finalQuantity = parseInt(document.getElementById('quantity').value) || 1;
            
            // Get current state of all lines with detailed client information
            const lineStates = lines.map(line => {
                const info = getLineInfo(line);
                const clients = stockEntries.filter(entry => entry.lines.includes(line));
                const sameClientEntries = clients.filter(entry => entry.clientCode === clientInfo.code);
                const otherClientEntries = clients.filter(entry => entry.clientCode !== clientInfo.code);
                
                return {
                    line,
                    available: 22 - info.quantity,
                    sameClientQuantity: sameClientEntries.reduce((sum, entry) => sum + entry.quantity, 0),
                    otherClients: otherClientEntries.map(entry => ({
                        clientCode: entry.clientCode,
                        quantity: entry.quantity,
                        dateTime: entry.dateTime
                    })),
                    latestDate: clients.length > 0 ? 
                        Math.max(...clients.map(entry => new Date(entry.dateTime).getTime())) : 0
                };
            });

            // First, find lines where this client already has cuves for the same datetime
            const existingClientLines = lineStates.filter(state => {
                const existingEntry = stockEntries.find(entry => 
                    entry.lines.includes(state.line) && 
                    entry.clientCode === clientInfo.code &&
                    entry.dateTime === dateTime
                );
                return existingEntry && state.available > 0;
            });

            if (existingClientLines.length > 0) {
                // Calculate if we need additional lines
                const totalExistingSpace = existingClientLines.reduce((sum, state) => sum + state.available, 0);
                const suggestions = existingClientLines.map(state => state.line);

                if (finalQuantity > totalExistingSpace) {
                    // Need more space, find additional lines
                    const additionalSpaceNeeded = finalQuantity - totalExistingSpace;
                    
                    // First try empty lines
                    const emptyLines = lineStates
                        .filter(state => state.available === 22)
                        .map(state => state.line);
                    
                    if (emptyLines.length > 0) {
                        suggestions.push(emptyLines[0]);
                    } else {
                        // Find partially filled lines, prioritizing by date
                        const partialLines = lineStates
                            .filter(state => !suggestions.includes(state.line) && state.available > 0)
                            .sort((a, b) => {
                                // Sort by latest date (newer dates first)
                                return b.latestDate - a.latestDate;
                            });

                        if (partialLines.length > 0) {
                            suggestions.push(partialLines[0].line);
                        }
                    }
                }

                return suggestions;
            }

            // If no existing lines with this client, prefer empty lines
            const emptyLines = lineStates
                .filter(state => state.available === 22)
                .map(state => state.line);

            if (emptyLines.length > 0) {
                return [emptyLines[0]];
            }

            // If no empty lines, find lines with most available space, sorted by date
            return lineStates
                .filter(state => state.available > 0)
                .sort((a, b) => {
                    // First sort by available space (descending)
                    if (b.available !== a.available) {
                        return b.available - a.available;
                    }
                    // Then by latest date (newer dates first)
                    return b.latestDate - a.latestDate;
                })
                .slice(0, 1)
                .map(state => state.line);
        }

        function useSuggestion() {
            const suggestions = getSuggestedLines();
            selectedLines = [...suggestions];
            updateLinesGrid();
        }

        function getLineInfo(lineNumber) {
            const entries = stockEntries.filter(entry => entry.lines.includes(lineNumber));
            const totalCuves = entries.reduce((sum, entry) => sum + entry.quantity, 0);
            return {
                occupied: totalCuves >= 22,
                client: entries.map(e => e.clientName).join(', '),
                quantity: totalCuves,
                dateTime: entries.map(e => e.dateTime).join(', '),
                remainingCapacity: 22 - totalCuves,
                isFull: totalCuves === 22
            };
        }

        function getLineColor(lineNumber) {
            const info = getLineInfo(lineNumber);
            const suggestions = getSuggestedLines();
            
            if (selectedLines.includes(lineNumber)) return 'bg-green-500 text-white';
            if (suggestions.includes(lineNumber)) return 'bg-orange-200 border-orange-500';
            if (info.occupied) return 'bg-red-500 text-white';
            if (info.quantity > 0) return 'bg-yellow-200 hover:bg-yellow-300';
            return 'bg-gray-200 hover:bg-gray-300';
        }

        function handleLineToggle(lineNumber) {
            const info = getLineInfo(lineNumber);
            if (info.occupied) return;

            if (selectedLines.includes(lineNumber)) {
                selectedLines = selectedLines.filter(l => l !== lineNumber);
            } else {
                selectedLines.push(lineNumber);
            }
            updateLinesGrid();
        }

        function generateLinesGrid() {
            const linesGrid = document.getElementById('linesGrid');
            if (linesGrid) {
                linesGrid.innerHTML = '';
                const linesGridContainer = document.createElement('div');
                linesGridContainer.className = 'grid grid-cols-2 md:grid-cols-7 gap-1 w-full';
                for (let line = 1; line <= 14; line++) {
                    // Regroupement par client/date/heure pour cette ligne
                    const grouped = getGroupedEntries(stockEntries.filter(e => e.lines && e.lines.includes(line)));
                    const hasCuve = grouped.length > 0;
                    const btn = document.createElement('div');
                    btn.className = 'flex flex-col items-center justify-center rounded border font-bold text-sm cursor-pointer shadow transition-all duration-200 min-w-[70px] p-1 ' + (hasCuve ? 'bg-green-500 text-white' : 'bg-white');
                    btn.style.overflow = 'hidden';
                    btn.style.textAlign = 'center';
                    btn.style.minHeight = hasCuve ? `${60 + 32 * grouped.length}px` : '70px';
                    btn.innerHTML = `<div class='text-lg font-bold mb-1'>${line}</div>`;
                    if (hasCuve) {
                        // Afficher un seul nom de client par groupe, avec la quantité totale
                        const clientInfo = grouped.map((e, idx) => {
                            // Vérifie si la date est invalide
                            const isInvalid = !parseDateTime(e.dateTime);
                            return `<div class='w-full flex flex-col items-center'>
                                <span class='block text-xs font-semibold truncate max-w-[60px]' title='${e.clientName || ''}' style='${isInvalid ? 'color:red;text-decoration:underline;cursor:pointer;' : ''}' onclick='${isInvalid ? `window.showEditCuvePopup(${JSON.stringify(e).replace(/'/g,"&#39;")},0)` : ''}'>${e.clientName || ''} ${e.quantity}C${isInvalid ? ' ⚠️' : ''}</span>
                            </div>`;
                        }).join('');
                        btn.innerHTML += `<div class='w-full flex flex-col items-center gap-1 mt-1'>${clientInfo}</div>`;
                        btn.innerHTML += `<div class='text-xs mt-2 font-bold'>${grouped.length} client${grouped.length > 1 ? 's' : ''}</div>`;
                    }
                    btn.onclick = function() {
                        showLineDetailsPopup(line);
                    };
                    linesGridContainer.appendChild(btn);
                }
                // Ajoute la zone prélèvement à la fin de la grille dans Ajouter
                const prelevBtn = document.createElement('div');
                prelevBtn.className = 'flex flex-col items-center justify-center rounded-xl font-bold text-base border cursor-pointer shadow transition-all duration-200 min-w-[70px] p-1 bg-pink-200 text-pink-800';
                prelevBtn.style.overflow = 'hidden';
                prelevBtn.style.textAlign = 'center';
                prelevBtn.style.minHeight = '70px';
                prelevBtn.innerHTML = `<div class='text-lg font-bold mb-1'>Prélèvement</div>`;
                // Afficher les cuves dans la zone prélèvement
                const prelevEntries = stockEntries.filter(e => e.lines && e.lines.includes(0));
                if (prelevEntries.length) {
                    prelevBtn.innerHTML += prelevEntries.map(e =>
                        (e.cuveIds || []).map((cuveId, idx) =>
                            `<div class='w-full flex flex-col items-center mt-1'>
                                <span class='block text-xs font-semibold truncate max-w-[60px] cursor-pointer underline' title='${e.clientName || ''}' onclick='showPrelevementReturnPopup("${cuveId}")'>${e.clientName || ''} ${cuveId}</span>
                            </div>`
                        ).join('')
                    ).join('');
                }
                linesGridContainer.appendChild(prelevBtn);
                prelevBtn.onclick = showPrelevementCuvePopup;
                linesGrid.appendChild(linesGridContainer);
            }
        }

        function updateLinesGrid() {
            const grid = document.getElementById('linesGrid');
            const linesGridContainer = grid.firstElementChild;
            if (!linesGridContainer) return;
            const buttons = linesGridContainer.children;
            const suggestions = getSuggestedLines();
            lines.forEach((line, index) => {
                const button = buttons[index];
                const info = getLineInfo(line);
                let extraClass = '';
                if (selectedLines.includes(line)) {
                    extraClass = 'bg-green-500 text-white border-green-700';
                } else if (suggestions.includes(line)) {
                    extraClass = 'bg-orange-200 border-orange-500';
                } else if (info.quantity > 0) {
                    extraClass = 'bg-green-200 border-green-500';
                } else {
                    extraClass = 'bg-gray-200 border-gray-300';
                }
                button.className = `flex flex-col items-center justify-center rounded border font-bold text-sm cursor-pointer shadow transition-all duration-200 min-w-[70px] p-1 ${extraClass}`;
                button.disabled = false;
                let title = '';
                if (info.occupied) {
                    title = `Ligne pleine: ${info.client} (${info.quantity} cuves)`;
                } else if (info.quantity > 0) {
                    title = `${info.client} (${info.quantity} cuves) - Reste ${info.remainingCapacity} places`;
                } else if (suggestions.includes(line)) {
                    title = 'SUGGÉRÉ';
                }
                button.title = title;
                button.innerHTML = `<div class='text-lg font-bold mb-1'>${line}</div>`;
                if (info.quantity > 0 && !info.occupied) {
                    button.innerHTML += `<div class="text-xs text-orange-600">${info.quantity}/22</div>`;
                }
                if (suggestions.includes(line)) {
                    button.innerHTML += '<div class="text-xs text-orange-600">SUGGÉRÉ</div>';
                }
            });
        }

        async function showPopup(options) {
            const popup = document.getElementById('popup');
            const title = document.getElementById('popupTitle');
            const message = document.getElementById('popupMessage');
            const icon = document.getElementById('popupIcon');
            const confirmBtn = document.getElementById('popupConfirmBtn');
            const cancelBtn = document.getElementById('popupCancelBtn');

            title.textContent = options.title || '';
            message.textContent = options.message || '';
            icon.textContent = options.icon || '';
            confirmBtn.textContent = options.confirmText || 'OK';
            
            if (options.showCancel) {
                cancelBtn.classList.remove('hidden');
                cancelBtn.textContent = options.cancelText || 'Annuler';
            } else {
                cancelBtn.classList.add('hidden');
            }

            popup.classList.remove('hidden');

            return new Promise((resolve) => {
                const handleConfirm = () => {
                    popup.classList.add('hidden');
                    cleanup();
                    resolve(true);
                };

                const handleCancel = () => {
                    popup.classList.add('hidden');
                    cleanup();
                    resolve(false);
                };

                const handleOutsideClick = (e) => {
                    if (e.target === popup) {
                        handleCancel();
                    }
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    popup.removeEventListener('click', handleOutsideClick);
                };

                confirmBtn.addEventListener('click', handleConfirm);
                cancelBtn.addEventListener('click', handleCancel);
                popup.addEventListener('click', handleOutsideClick);
            });
        }

        function updateCuveIdFields() {
            const container = document.getElementById('cuveIdFields');
            let qty = parseInt(document.getElementById('quantity').value) || 0;

            // Reset cuveIds array to match new quantity
            cuveIds = cuveIds.slice(0, qty);
            while (cuveIds.length < qty) {
                cuveIds.push('');
            }

            if (qty > 0) {
                let html = `
                    <label class="block text-sm font-bold text-gray-700 mb-2">
                        Identifiants des cuves
                    </label>
                    <div class="space-y-2">
                `;
                for (const index of Array.from({length: qty}).keys()) {
                    html += `
                        <input
                            type="text"
                            class="cuveId w-full p-3 border-2 border-gray-300 rounded-lg text-lg"
                            placeholder="ID Cuve ${index + 1}"
                            value="${cuveIds[index]}"
                            onchange="updateCuveId(${index}, this.value)"
                        />
                    `;
                }
                html += '</div>';
                container.innerHTML = html;
            } else {
                container.innerHTML = '';
            }
        }

        function updateCuveId(index, value) {
            cuveIds[index] = value;
        }

        async function addStock() {
            const clientInfo = getClientInfo(clientCode);
            if (!clientInfo) {
                await showPopup({
                    title: 'Erreur',
                    message: 'Code ou nom client non reconnu !',
                    icon: '⚠️'
                });
                return;
            }
            if (!quantity) {
                document.getElementById('quantity').value = 1;
                quantity = 1;
            }
            if (!dateTime) {
                await showPopup({
                    title: 'Erreur',
                    message: 'Veuillez saisir une date et heure valides',
                    icon: '⚠️'
                });
                return;
            }
            const quickCuveId = document.getElementById('quickCuveId').value.trim();
            let linesToUse = selectedLines.slice();
            let finalQuantity = quantity ? parseInt(quantity) : linesToUse.length;
            if (finalQuantity === 1) {
                if (quickCuveId) {
                    cuveIds = [quickCuveId];
                } else if (!cuveIds.length || !cuveIds[0]) {
                    await showPopup({
                        title: 'Erreur',
                        message: 'Veuillez saisir l\'identifiant de la cuve',
                        icon: '⚠️'
                    });
                    return;
                }
            }
            if (finalQuantity > 0 && cuveIds.length !== finalQuantity) {
                await showPopup({
                    title: 'Erreur',
                    message: 'Veuillez saisir tous les identifiants des cuves',
                    icon: '⚠️'
                });
                return;
            }
            for (const cuveId of cuveIds) {
                if (!cuveId) continue;
                const alreadyInOtherFridge = stockEntries.some(entry =>
                    entry.cuveIds && entry.cuveIds.includes(cuveId)
                );
                if (alreadyInOtherFridge) {
                    await showPopup({
                        title: 'Erreur',
                        message: `Le tank (ID: ${cuveId}) existe déjà dans le frigo. Un tank ne peut pas être dans deux emplacements différents !`,
                        icon: '⚠️'
                    });
                    return;
                }
            }
            const newDateObj = parseDateTime(dateTime);
            // ENFORCE: FIFO strict placement for each line, but allow same date/hour for same client
            let forceAdd = false;
            for (const line of linesToUse) {
                const entries = stockEntries.filter(entry => entry.lines.includes(line));
                // Sort entries by dateTime (oldest at front, newest at back)
                const sorted = entries.slice().sort((a, b) => {
                    const da = parseDateTime(a.dateTime);
                    const db = parseDateTime(b.dateTime);
                    return da - db;
                });
                for (const entry of sorted) {
                    const entryDate = parseDateTime(entry.dateTime);
                    if (!entryDate) continue;
                    // Allow same date/hour if same client, otherwise must be strictly earlier
                    if (entry.clientCode !== clientInfo.code && !(newDateObj < entryDate)) {
                        const confirmed = await showPopup({
                            title: 'Erreur de placement',
                            message: `Pour la ligne ${line}, la date/heure du nouveau tank doit être strictement antérieure à celle du tank déjà présent devant (${entry.dateTime}) car il appartient à un client différent.\n\nVoulez-vous forcer l'ajout malgré tout ?`,
                            icon: '⚠️',
                            confirmText: 'Forcer l\'ajout',
                            cancelText: 'Annuler',
                            showCancel: true
                        });
                        if (!confirmed) return;
                        forceAdd = true;
                        break;
                    }
                }
                if (forceAdd) break;
            }
            for (const line of linesToUse) {
                const info = getLineInfo(line);
                const totalAfterAdd = info.quantity + finalQuantity;
                
                if (totalAfterAdd > 22) {
                    await showPopup({
                        title: 'Erreur',
                        message: `La ligne ${line} dépasserait 22 cuves (${totalAfterAdd} au total)`,
                        icon: '⚠️'
                    });
                    return;
                }
            }

            // Calculate total available capacity for selected lines
            const totalAvailableCapacity = linesToUse.reduce((sum, line) => {
                const info = getLineInfo(line);
                return sum + info.remainingCapacity;
            }, 0);

            // Validate against available capacity
            if (finalQuantity > totalAvailableCapacity) {
                await showPopup({
                    title: 'Capacité insuffisante',
                    message: `Les lignes sélectionnées peuvent encore accueillir ${totalAvailableCapacity} cuves maximum.`,
                    icon: '⚠️'
                });
                return;
            }

            // Check for existing entries to merge
            let existingEntryIndex = stockEntries.findIndex(entry => 
                entry.clientCode === clientInfo.code && 
                entry.dateTime === dateTime && 
                entry.lines.some(line => linesToUse.includes(line))
            );

            if (existingEntryIndex !== -1) {
                // Merge with existing entry
                const existingEntry = stockEntries[existingEntryIndex];
                const updatedEntry = {
                    ...existingEntry,
                    quantity: existingEntry.quantity + finalQuantity,
                    lines: [...new Set([...existingEntry.lines, ...linesToUse])],
                    cuveIds: [...(existingEntry.cuveIds || []), ...(cuveIds || [])]
                };

                // Validate total quantity after merge
                const totalQuantityAfterMerge = updatedEntry.quantity;
                const totalCapacityForLines = updatedEntry.lines.reduce((sum, line) => {
                    const info = getLineInfo(line);
                    return sum + (22 - info.quantity) + (existingEntry.lines.includes(line) ? existingEntry.quantity : 0);
                }, 0);

                if (totalQuantityAfterMerge > totalCapacityForLines) {
                    await showPopup({
                        title: 'Capacité insuffisante',
                        message: `La fusion dépasserait la capacité disponible des lignes sélectionnées.`,
                        icon: '⚠️'
                    });
                    return;
                }

                stockEntries[existingEntryIndex] = updatedEntry;
                
                // Reset form
                clientCode = '';
                quantity = '';
                linesToUse = [];
                cuveIds = [];
                document.getElementById('clientCode').value = '';
                document.getElementById('quantity').value = '';
                document.getElementById('cuveIdFields').innerHTML = '';
                document.getElementById('quickCuveId').value = '';
                
                // Reset date and time
                const oldDateTime = dateTime;  // Store the old value for debugging
                dateTime = '';
                document.getElementById('loadingDateTime').value = '';
                console.log('Reset dateTime from', oldDateTime, 'to empty string');
                
                // updateUI();
                updateGroupingInfo();
                updateLinesGrid();
                updateStockViewAndSave();
                
                await showPopup({
                    title: 'Succès',
                    message: 'Stock ajouté avec succès!',
                    icon: '✅'
                });
                updateStockCount();

                return;
            }

            // If not merging, add new entry
            const newEntry = {
                clientCode: clientInfo.code,
                clientName: clientInfo.name,
                quantity: finalQuantity,
                lines: linesToUse.slice(),
                cuveIds: cuveIds.slice(),
                dateTime: dateTime,
                user: currentUser
            };
            stockEntries.push(newEntry);

            // Reset form
            clientCode = '';
            quantity = '';
            linesToUse = [];
            cuveIds = [];
            document.getElementById('clientCode').value = '';
            document.getElementById('quantity').value = '';
            document.getElementById('cuveIdFields').innerHTML = '';
            document.getElementById('quickCuveId').value = '';

            // Reset date and time
            const oldDateTime = dateTime;  // Store the old value for debugging
            dateTime = '';
            document.getElementById('loadingDateTime').value = '';
            console.log('Reset dateTime from', oldDateTime, 'to empty string');

            // updateUI();
            updateGroupingInfo();
            updateLinesGrid();
            updateStockViewAndSave();

            await showPopup({
                title: 'Succès',
                message: 'Stock ajouté avec succès!',
                icon: '✅'
            });
            updateStockCount();
            return;
        }

        function filterStockByCuveId() {
            const searchTerm = document.getElementById('searchCuveId').value.toLowerCase();
            const stockList = document.getElementById('stockList');
            highlightedLines = [];
            if (!searchTerm) {
                updateStockView();
                return;
            }
            const filtered = stockEntries.filter(entry =>
                entry.cuveIds && entry.cuveIds.some(id => id.toLowerCase().includes(searchTerm))
            );
            if (filtered.length === 0) {
                stockList.innerHTML = `
                    <div class="text-center py-8 text-gray-500">
                        ❌ Aucune cuve trouvée avec l'ID "${searchTerm}"
                    </div>
                `;
                updateStockView();
                return;
            }
            // Collect all lines to highlight
            highlightedLines = filtered.flatMap(entry => entry.lines);
            let html = '<h3 class="text-lg font-bold mb-3">Résultat de la recherche</h3><div class="space-y-4">';
            filtered.forEach(entry => {
                entry.cuveIds.forEach((id, idx) => {
                    if (id.toLowerCase().includes(searchTerm)) {
                        html += `
                            <div class="border rounded-lg p-4 bg-blue-50">
                                <div class="font-bold text-lg mb-2">
                                    ${entry.clientName} (${entry.clientCode})
                                </div>
                                <div class="text-sm text-gray-700">
                                    <b>ID:</b> ${id}${entry.user ? ` <span class=\"bg-gray-200 rounded px-1 text-xs font-bold ml-1\">${entry.user[0].toUpperCase()}</span>` : ''}<br>
                                    <b>Quantité:</b> ${entry.quantity}<br>
                                    <b>Ligne(s):</b> ${entry.lines.join(', ')}<br>
                                    <b>Date/Heure:</b> ${entry.dateTime}<br>
                                    <b>Ajouté par:</b> ${entry.user ? entry.user : 'N/A'}
                                </div>
                            </div>
                        `;
                    }
                });
            });
            html += '</div>';
            stockList.innerHTML = html;
            updateStockView();
        }

        // Add JS for search and results rendering
        (function() {
            const searchBox = document.getElementById('stockSearchBox');
            const suggestionsDiv = document.getElementById('stockSearchSuggestions');
            const resultsDiv = document.getElementById('stockSearchResults');
            const nouveauFrigoGrid = document.getElementById('stockNouveauFrigoGrid');

            // Autocomplete suggestions
            if (searchBox) {
                searchBox.addEventListener('input', function() {
                    const term = searchBox.value.trim().toLowerCase();
                    // Suggestions
                    if (term) {
                        let suggestions = [];
                        // Tank numbers
                        stockEntries.forEach(e => {
                            (e.cuveIds || []).forEach(id => {
                                if (id && id.toLowerCase().includes(term) && !suggestions.includes(id)) {
                                    suggestions.push(id);
                                }
                            });
                        });
                        // Client names
                        stockEntries.forEach(e => {
                            if (e.clientName && e.clientName.toLowerCase().includes(term) && !suggestions.includes(e.clientName)) {
                                suggestions.push(e.clientName);
                            }
                        });
                        // Client codes
                        stockEntries.forEach(e => {
                            if (e.clientCode && e.clientCode.toLowerCase().includes(term) && !suggestions.includes(e.clientCode)) {
                                suggestions.push(e.clientCode);
                            }
                        });
                        if (suggestions.length > 0) {
                            suggestionsDiv.innerHTML = suggestions.slice(0, 10).map(s => `<div class='px-4 py-2 hover:bg-blue-100 cursor-pointer'>${s}</div>`).join('');
                            suggestionsDiv.classList.remove('hidden');
                        } else {
                            suggestionsDiv.innerHTML = '';
                            suggestionsDiv.classList.add('hidden');
                        }
                    } else {
                        suggestionsDiv.innerHTML = '';
                        suggestionsDiv.classList.add('hidden');
                    }
                    // Search results
                    if (!term) {
                        resultsDiv.innerHTML = '';
                        return;
                    }
                    let html = '';
                    for (let line = 1; line <= 14; line++) {
                        const entries = stockEntries.filter(e => e.lines && e.lines.includes(line));
                        const matching = entries.filter(e => {
                            const cuveMatch = (e.cuveIds || []).some(id => id.toLowerCase().includes(term));
                            const clientMatch = (e.clientName || '').toLowerCase().includes(term) || (e.clientCode || '').toLowerCase().includes(term);
                            return cuveMatch || clientMatch;
                        });
                        if (matching.length > 0) {
                            html += `<div class='mb-4 p-3 bg-white rounded shadow border'>`;
                            html += `<div class='font-bold mb-1'>Ligne ${line}</div>`;
                            matching.forEach(e => {
                                html += `<div class='text-xs mb-1 border-b border-gray-200 pb-1'>Client: ${e.clientName || ''} (${e.clientCode || ''})<br>Cuves: ${(e.cuveIds || []).join(', ')}<br>Date/Heure: ${e.dateTime || ''}</div>`;
                            });
                            html += `</div>`;
                        }
                    }
                    resultsDiv.innerHTML = html || '<div class="text-gray-400">Aucun résultat</div>';
                });
                // Suggestion click
                suggestionsDiv.addEventListener('mousedown', function(e) {
                    if (e.target && e.target.textContent) {
                        searchBox.value = e.target.textContent;
                        suggestionsDiv.classList.add('hidden');
                        searchBox.dispatchEvent(new Event('input'));
                    }
                });
                // Hide suggestions on blur (with delay for click)
                searchBox.addEventListener('blur', function() {
                    setTimeout(() => suggestionsDiv.classList.add('hidden'), 150);
                });
                searchBox.addEventListener('focus', function() {
                    if (suggestionsDiv.innerHTML) suggestionsDiv.classList.remove('hidden');
                });
            }
        })();

        // ==============================================
        // Stock Management
        // ==============================================
        
        function updateStockCount() {
            const stockCountSpan = document.getElementById('stockCount');
            if (stockCountSpan) {
                let total = 0;
                stockEntries.forEach(entry => {
                    total += entry.quantity || 0;
                });
                stockCountSpan.textContent = total;
            }
        }

        function updateStockView() {
            const resultsDiv = document.getElementById('stockSearchResults');
            const stockCountSpan = document.getElementById('stockCount');
            if (stockCountSpan) {
                let total = 0;
                stockEntries.forEach(entry => {
                    total += entry.quantity || 0;
                });
                stockCountSpan.textContent = total;
            }

            const nouveauFrigoGrid = document.getElementById('stockNouveauFrigoGrid');
            if (nouveauFrigoGrid) {
                nouveauFrigoGrid.innerHTML = '';
                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-2 md:grid-cols-7 gap-2 w-full';
                for (let line = 1; line <= 14; line++) {
                    const entries = stockEntries.filter(e => e.lines && e.lines.includes(line));
                    const grouped = getGroupedEntries(entries);
                    const hasCuve = grouped.length > 0;
                    const btn = document.createElement('div');
                    btn.className = 'flex flex-col items-center justify-center rounded-xl font-bold text-base border cursor-pointer shadow transition-all duration-200 min-w-[70px] p-1 ' + (hasCuve ? 'bg-green-500 text-white' : 'bg-white');
                    btn.style.overflow = 'hidden';
                    btn.style.textAlign = 'center';
                    btn.style.minHeight = hasCuve ? `${60 + 32 * grouped.length}px` : '70px';
                    btn.innerHTML = `<div class='text-lg font-bold mb-1'>${line}</div>`;
                    if (hasCuve) {
                        const clientInfo = grouped.map(e =>
                            `<div class='w-full flex flex-col items-center'>
                                <span class='block text-xs font-semibold truncate max-w-[60px]' title='${e.clientName || ''}'>${e.clientName || ''} ${e.quantity}C</span>
                            </div>`
                        ).join('');
                        btn.innerHTML += `<div class='w-full flex flex-col items-center gap-1 mt-1'>${clientInfo}</div>`;
                        btn.innerHTML += `<div class='text-xs mt-2 font-bold'>${grouped.length} client${grouped.length > 1 ? 's' : ''}</div>`;
                    }
                    btn.onclick = function() {
                        const lineEntries = getGroupedEntries(stockEntries.filter(e => e.lines && e.lines.includes(line)));
                        if (!lineEntries.length) return;
                        let html = `<div class='font-bold text-lg mb-4'>Ligne ${line}</div>`;
                        const pastel = ['bg-blue-50 border-blue-200','bg-green-50 border-green-200','bg-yellow-50 border-yellow-200','bg-pink-50 border-pink-200','bg-purple-50 border-purple-200','bg-orange-50 border-orange-200','bg-teal-50 border-teal-200'];
                        html += `<div class='flex flex-wrap gap-3'>`;
                        lineEntries.forEach((e, idx) => {
                            const color = pastel[idx % pastel.length];
                            html += `<div class='p-3 rounded-lg border ${color} min-w-[180px] flex-1'>
                                <div class='font-bold text-base mb-1'>${e.clientName}</div>
                                <div class='text-xs text-gray-700 mb-1'><b>Cuves :</b> <span class='text-blue-700 font-bold'>${e.quantity}</span></div>
                                <div class='text-xs text-gray-700'><b>Heure :</b> ${formatDateFr(parseDateTime(e.dateTime))}</div>
                            </div>`;
                        });
                        html += `</div>`;
                        const popupDiv = document.createElement('div');
                        popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
                        popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-4xl w-full mx-4 relative' style='max-width:1000px;'>
                            <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(\".fixed\").remove()'>&times;</button>
                            ${html}
                        </div>`;
                        document.body.appendChild(popupDiv);
                        e.stopPropagation();
                        prelevBtn.onclick = showPrelevementCuvePopup;
                    };
                    grid.appendChild(btn);
                }
                // Ajoute la zone prélèvement
                const prelevBtn = document.createElement('div');
                prelevBtn.className = 'flex flex-col items-center justify-center rounded-xl font-bold text-base border cursor-pointer shadow transition-all duration-200 min-w-[70px] min-h-[70px] p-1 bg-pink-200 text-pink-800';
                prelevBtn.style.overflow = 'hidden';
                prelevBtn.style.textAlign = 'center';
                prelevBtn.innerHTML = `<div class='text-lg font-bold mb-1'>Prélèvement</div>`;
                // Afficher les cuves dans la zone prélèvement
                const prelevEntries = stockEntries.filter(e => e.lines && e.lines.includes(0));
                if (prelevEntries.length) {
                    prelevBtn.innerHTML += prelevEntries.map(e =>
                        (e.cuveIds || []).map((cuveId, idx) =>
                            `<div class='w-full flex flex-col items-center mt-1'>
                                <span class='block text-xs font-semibold truncate max-w-[60px] cursor-pointer underline' title='${e.clientName || ''}' onclick='showPrelevementReturnPopup("${cuveId}")'>${e.clientName || ''} ${cuveId}</span>
                            </div>`
                        ).join('')
                    ).join('');
                }
                // Ajoute le petit bouton à droite de prélèvement, même style
                const prelevRow = document.createElement('div');
                prelevRow.className = 'flex flex-row items-center gap-2';
                prelevRow.appendChild(prelevBtn);
                if (!document.getElementById('deleteLineBtnStockMini')) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.id = 'deleteLineBtnStockMini';
                    deleteBtn.className = 'flex items-center justify-center rounded-xl font-bold text-lg border cursor-pointer shadow min-w-[70px] min-h-[70px] p-1 bg-red-500 hover:bg-red-600 text-white';
                    deleteBtn.title = 'Supprimer une ligne';
                    deleteBtn.innerHTML = '🗑️';
                    deleteBtn.onclick = showDeleteLinePopup;
                    prelevRow.appendChild(deleteBtn);
                }
                grid.appendChild(prelevRow);
                nouveauFrigoGrid.appendChild(grid);
            }
            if (!resultsDiv) return;
            if (!stockEntries.length) {
                resultsDiv.innerHTML = '<div class="text-gray-400">Aucune cuve en stock.</div>';
                return;
            }
            let html = '<h3 class="text-lg font-bold mb-3">Stock actuel</h3><div class="space-y-4">';
            getGroupedEntries(stockEntries).forEach((entry, i) => {
                // Pour chaque cuve, vérifie si la date est invalide
                let cuveIdsHtml = (entry.cuveIds || []).map((id, idx) => {
                    const isInvalid = !parseDateTime(entry.dateTime);
                    return isInvalid
                        ? `<span style='color:red;text-decoration:underline;cursor:pointer;' onclick='window.showEditCuvePopup(${JSON.stringify(entry).replace(/'/g,"&#39;")},${idx})'>${id} ⚠️</span>`
                        : `<span>${id}</span>`;
                }).join(', ');
                html += `<div class="border rounded-lg p-4 bg-blue-50 mb-2">
                    <div class="font-bold text-lg mb-2">${entry.clientName} (${entry.clientCode})</div>
                    <div class="text-sm text-gray-700">
                        <b>Quantité:</b> ${entry.quantity}<br>
                        <b>Ligne(s):</b> ${entry.lines.join(', ')}<br>
                        <b>ID(s):</b> ${cuveIdsHtml}<br>
                        <b>Date/Heure:</b> ${formatDateFr(parseDateTime(entry.dateTime))}
                    </div>
                    <div class='flex justify-end mt-2'>
                        <button class='bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded font-bold text-xs' onclick='showDeleteClientPopupFromStock(${i})'>🗑️</button>
                    </div>
                </div>`;
            });
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        async function removeTanksForClientOnLine(clientName, line) {
            const confirmed = await showPopup({
                title: 'Confirmation',
                message: `Supprimer toutes les cuves de ${clientName} sur la ligne ${line} ?`,
                icon: '⚠️',
                confirmText: 'Supprimer',
                cancelText: 'Annuler',
                showCancel: true
            });
            if (!confirmed) return;
            stockEntries = stockEntries.filter(entry => !(entry.clientName === clientName && entry.lines.includes(line)));
            updateStockViewAndSave();
            updateStockCount();
            await showPopup({
                title: 'Succès',
                message: 'Cuves supprimées pour ce client sur cette ligne.',
                icon: '✅'
            });
        }

        // 1. Ajouter le bouton en haut de l'onglet Stock
        const stockTabContent = document.getElementById('stockTabContent');
        if (stockTabContent && !document.getElementById('groupT3T4Btn')) {
            const groupBtn = document.createElement('button');
            groupBtn.id = 'groupT3T4Btn';
            groupBtn.className = 'mb-4 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-bold text-base w-full';
            groupBtn.innerText = 'Regrouper Barilla T3 et T4';
            groupBtn.style.display = 'none';
            stockTabContent.insertBefore(groupBtn, stockTabContent.firstChild);
            groupBtn.onclick = async function() {
                // Chercher les entrées T3 et T4
                const t3 = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('barilla t3') && e.quantity > 0);
                const t4 = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('barilla t4') && e.quantity > 0);
                if (!t3 || !t4) return;
                const t3Line = t3.lines[0];
                const t4Line = t4.lines[0];
                let message = `Regrouper les clients ?`;
                const confirmed = await showPopup({
                    title: 'Regrouper les clients',
                    message,
                    icon: '🤝',
                    confirmText: 'Oui, regrouper',
                    cancelText: 'Annuler',
                    showCancel: true
                });
                if (!confirmed) return;
                t3.lines = [t4.lines[0]];
                updateStockViewAndSave();
                document.getElementById('groupT3T4Btn').style.display = 'none';
                // Masquer le message de suggestion de regroupement s'il existe
                const regroupMsg = document.getElementById('groupT3T4Suggestion');
                if (regroupMsg) regroupMsg.innerHTML = '';
                await showPopup({
                    title: 'Succès',
                    message: 'T3 et T4 sont maintenant regroupés.',
                    icon: '✅'
                });
            };
        }
        // 2. Afficher/masquer le bouton selon la présence de T3 et T4
        function updateGroupT3T4Btn() {
            const groupBtn = document.getElementById('groupT3T4Btn');
            if (!groupBtn) return;
            const t3 = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('barilla t3') && e.quantity > 0);
            const t4 = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('barilla t4') && e.quantity > 0);
            // Afficher le bouton seulement si T3 et T4 existent ET sont sur des lignes différentes ET ont la même date/heure
            let show = false;
            if (t3 && t4 && t3.lines[0] !== t4.lines[0]) {
                // Vérifier même date/heure
                if (t3.dateTime === t4.dateTime) {
                    show = true;
                }
            }
            groupBtn.style.display = show ? '' : 'none';
            // Afficher/masquer le message de suggestion
            let suggestionDiv = document.getElementById('groupT3T4Suggestion');
            if (!suggestionDiv) {
                suggestionDiv = document.createElement('div');
                suggestionDiv.id = 'groupT3T4Suggestion';
                groupBtn.parentNode.insertBefore(suggestionDiv, groupBtn.nextSibling);
            }
            suggestionDiv.innerHTML = show ? '<div class="mb-2 p-2 bg-blue-50 border border-blue-200 rounded text-blue-800 font-medium">T3 et T4 ont des cuves à la même date/heure sur des lignes différentes. Vous pouvez les regrouper.</div>' : '';
        }
        // Appeler updateGroupT3T4Btn à chaque updateStockView
        const _oldUpdateStockView = updateStockView;
        updateStockView = function() {
            _oldUpdateStockView.apply(this, arguments);
            updateGroupT3T4Btn();
        };

        // 1. Ajouter le bouton de regroupement Brioche
        if (stockTabContent && !document.getElementById('groupBriocheBtn')) {
            const groupBtn = document.createElement('button');
            groupBtn.id = 'groupBriocheBtn';
            groupBtn.className = 'mb-4 bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded font-bold text-base w-full';
            groupBtn.innerText = 'Regrouper Brioche Cop/Heber/Fonteneau';
            groupBtn.style.display = 'none';
            stockTabContent.insertBefore(groupBtn, stockTabContent.firstChild);
            groupBtn.onclick = async function() {
                // Chercher les entrées
                const cop = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('brioche cop') && e.quantity > 0);
                const heber = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('brioche heber') && e.quantity > 0);
                const fonteneau = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('brioche fonteneau') && e.quantity > 0);
                if (!cop || !heber || !fonteneau) return;
                // Lignes actuelles
                const copLine = cop.lines[0];
                const heberLine = heber.lines[0];
                const fonteneauLine = fonteneau.lines[0];
                // Ligne cible = ligne de Fonteneau
                const targetLine = fonteneauLine;
                // Proposer de transférer sur la ligne de Fonteneau
                let message = `Voulez-vous transférer toutes les cuves de Brioche Cop (L${copLine}), puis Heber (L${heberLine}), puis Fonteneau (L${fonteneauLine}) sur la même ligne (ligne de Fonteneau, L${targetLine}) ?\n\nOrdre de chargement : Cop (L${copLine}), Heber (L${heberLine}) vers Fonteneau (L${fonteneauLine})`;
                const confirmed = await showPopup({
                    title: 'Regrouper Brioche',
                    message,
                    icon: '🍞',
                    confirmText: 'Oui, regrouper',
                    cancelText: 'Annuler',
                    showCancel: true
                });
                if (!confirmed) return;
                // Déplacer les cuves sur la ligne cible
                cop.lines = [targetLine];
                heber.lines = [targetLine];
                // (ne pas fusionner les entrées)
                updateStockViewAndSave();
                document.getElementById('groupBriocheBtn').style.display = 'none';
                // Masquer le message de suggestion de regroupement s'il existe
                const regroupMsg = document.getElementById('groupBriocheSuggestion');
                if (regroupMsg) regroupMsg.innerHTML = '';
                await showPopup({
                    title: 'Succès',
                    message: 'Brioche Cop, Heber et Fonteneau sont maintenant regroupés pour le chargement camion.',
                    icon: '✅'
                });
            };
        }
        // Afficher/masquer le bouton selon la présence des trois clients
        function updateGroupBriocheBtn() {
            const groupBtn = document.getElementById('groupBriocheBtn');
            if (!groupBtn) return;
            const cop = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('brioche cop') && e.quantity > 0);
            const heber = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('brioche heber') && e.quantity > 0);
            const fonteneau = stockEntries.find(e => e.clientName && e.clientName.toLowerCase().includes('brioche fonteneau') && e.quantity > 0);
            // Afficher le bouton seulement si les trois existent ET ont la même date/heure ET sont sur des lignes différentes
            let show = false;
            if (cop && heber && fonteneau) {
                if (cop.dateTime === heber.dateTime && heber.dateTime === fonteneau.dateTime) {
                    // Vérifier qu'ils ne sont pas déjà tous sur la même ligne
                    const lines = [cop.lines[0], heber.lines[0], fonteneau.lines[0]];
                    if (new Set(lines).size > 1) {
                        show = true;
                    }
                }
            }
            groupBtn.style.display = show ? '' : 'none';
            // Afficher/masquer le message de suggestion
            let suggestionDiv = document.getElementById('groupBriocheSuggestion');
            if (!suggestionDiv) {
                suggestionDiv = document.createElement('div');
                suggestionDiv.id = 'groupBriocheSuggestion';
                groupBtn.parentNode.insertBefore(suggestionDiv, groupBtn.nextSibling);
            }
            suggestionDiv.innerHTML = show ? '<div class="mb-2 p-2 bg-yellow-50 border border-yellow-200 rounded text-yellow-800 font-medium">Cop, Heber et Fonteneau ont des cuves à la même date/heure sur des lignes différentes. Vous pouvez les regrouper.</div>' : '';
        }
        // Appeler updateGroupBriocheBtn à chaque updateStockView
        const _oldUpdateStockView2 = updateStockView;
        updateStockView = function() {
            _oldUpdateStockView2.apply(this, arguments);
            updateGroupT3T4Btn && updateGroupT3T4Btn();
            updateGroupBriocheBtn();
        };

        // 1. Renommer le label de la zone de recherche
        const searchLabel = document.querySelector("label[for='stockSearchBox'], label.block.text-sm.font-bold.text-gray-700.mb-2");
        if (searchLabel) searchLabel.textContent = 'Recherche par numéro de cuve';
        // 2. Afficher une popup avec toutes les infos de la cuve trouvée
        const stockSearchBox = document.getElementById('stockSearchBox');
        if (stockSearchBox) {
            stockSearchBox.placeholder = 'Numéro de cuve...';
            stockSearchBox.onkeydown = async function(e) {
                if (e.key === 'Enter') {
                    const searchTerm = stockSearchBox.value.trim();
                    if (!searchTerm) return;
                    let found = null;
                    for (const entry of stockEntries) {
                        if (entry.cuveIds && entry.cuveIds.some(id => id.toLowerCase() === searchTerm.toLowerCase())) {
                            found = entry;
                            break;
                        }
                    }
                    if (found) {
                        const line = found.lines && found.lines.length ? found.lines[0] : '-';
                        await showPopup({
                            title: 'Détail de la cuve',
                            message: `Numéro de cuve : ${searchTerm}\nClient : ${found.clientName}\nLigne : ${line}\nDate/Heure : ${formatDateFr(parseDateTime(found.dateTime))}`,
                            icon: '🔎',
                            confirmText: 'OK'
                        });
                    } else {
                        await showPopup({
                            title: 'Alerte',
                            message: `Aucune cuve trouvée avec ce numéro.`,
                            icon: '❓',
                            confirmText: 'OK'
                        });
                    }
                }
            };
        }

        // 1. Ajout de l'onglet Chargement dans la navigation
        const navDiv = document.querySelector('.flex.mb-6.bg-white.rounded-lg.shadow.p-2');
        if (navDiv && !document.getElementById('loadingTab')) {
            const loadingBtn = document.createElement('button');
            loadingBtn.id = 'loadingTab';
            loadingBtn.className = 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
            loadingBtn.innerHTML = '🚚 Chargement';
            loadingBtn.onclick = function() { setActiveTab('loading'); };
            navDiv.appendChild(loadingBtn);
        }
        // 2. Ajout du contenu de l'onglet Chargement
        if (!document.getElementById('loadingTabContent')) {
            const loadingTabContent = document.createElement('div');
            loadingTabContent.id = 'loadingTabContent';
            loadingTabContent.className = 'bg-white rounded-lg shadow p-6 hidden';
            loadingTabContent.innerHTML = `
                <h2 class='text-2xl font-bold mb-6'>Préparer le plan de chargement</h2>
                <div id='loadingLines'></div>
                <button id='addLoadingLine' class='mt-4 mb-6 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded font-bold text-base'>Ajouter une ligne de chargement</button>
                <div id='loadingPlan' class='mt-8'></div>
            `;
            document.getElementById('mainApp').appendChild(loadingTabContent);
        }
        // 3. Gestion de l'affichage des onglets
        const _oldSetActiveTab = window.setActiveTab;
        window.setActiveTab = function(tab) {
            _oldSetActiveTab(tab);
            document.getElementById('loadingTabContent').classList.toggle('hidden', tab !== 'loading');
            document.getElementById('loadingTab').className = tab === 'loading'
                ? 'flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white'
                : 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
            if (tab === 'loading') updateLoadingList();
        };
        // 4. Affichage dynamique de la liste de chargement
        function updateLoadingList() {
            const loadingListDiv = document.getElementById('loadingLines');
            if (!loadingListDiv) return;
            // Récupérer tous les clients présents dans le stock (distincts, avec leur ligne et quantité)
            const clientsOnLines = [];
            for (let line = 1; line <= 14; line++) {
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(line));
                entries.forEach(e => {
                    if (!clientsOnLines.some(c => c.clientName === e.clientName)) {
                        clientsOnLines.push({
                            clientName: e.clientName,
                            line,
                            quantity: e.quantity,
                            cuveIds: e.cuveIds || []
                        });
                    }
                });
            }
            // Ordre de chargement (modifiable)
            if (!window.loadingOrder || window.loadingOrder.length !== clientsOnLines.length) {
                window.loadingOrder = clientsOnLines.map((c, i) => i);
            }
            // Appliquer l'ordre
            const orderedClients = window.loadingOrder.map(idx => clientsOnLines[idx]).filter(Boolean);
            // Affichage
            loadingListDiv.innerHTML = orderedClients.map((c, i) => `
                <div class='flex items-center gap-4 mb-2 p-2 bg-gray-50 rounded shadow'>
                    <div class='flex-1'>
                        <div class='font-bold text-lg'>${c.clientName || ''}</div>
                        <div class='text-xs text-gray-500'>Ligne : ${c.line} | ${c.cuveIds.length} cuve${c.cuveIds.length > 1 ? 's' : ''}</div>
                    </div>
                    <div class='flex flex-col gap-1'>
                        <button class='px-2 py-1 bg-gray-200 rounded hover:bg-gray-300' onclick='moveLoadingClient(${i},-1)' ${i === 0 ? 'disabled' : ''}>⬆️</button>
                        <button class='px-2 py-1 bg-gray-200 rounded hover:bg-gray-300' onclick='moveLoadingClient(${i},1)' ${i === orderedClients.length-1 ? 'disabled' : ''}>⬇️</button>
                    </div>
                </div>
            `).join('') || '<div class="text-gray-400">Aucun client à charger.</div>';
        }
        window.moveLoadingClient = function(index, dir) {
            if (!window.loadingOrder) return;
            const newIndex = index + dir;
            if (newIndex < 0 || newIndex >= window.loadingOrder.length) return;
            const tmp = window.loadingOrder[index];
            window.loadingOrder[index] = window.loadingOrder[newIndex];
            window.loadingOrder[newIndex] = tmp;
            updateLoadingList();
        };
        // Mettre à jour la liste si le mode change
        const loadingModeSelect = document.getElementById('loadingMode');
        if (loadingModeSelect) loadingModeSelect.onchange = updateLoadingList;

        // Gestion des lignes de chargement
        window.loadingLinesData = [];
        function renderLoadingLines() {
            const linesDiv = document.getElementById('loadingLines');
            if (!linesDiv) return;
            linesDiv.innerHTML = window.loadingLinesData.map((line, idx) => {
                return `
                <div class='flex flex-col md:flex-row items-center gap-2 mb-2 p-2 bg-gray-50 rounded shadow loading-line' data-idx='${idx}' style='cursor:pointer;'>
                    <div class='flex-1 flex flex-col md:flex-row gap-2 items-center'>
                        <input type='text' class='clientInput w-40 p-2 border rounded' placeholder='Code ou nom client' value='${line.client || ''}' data-idx='${idx}' autocomplete='off' />
                        <input type='text' class='dateInput w-32 p-2 border rounded' placeholder='JJ/MM HHh' value='${line.date || ''}' data-idx='${idx}' autocomplete='off' />
                        <span class='text-sm text-gray-700'>${line.cuves !== undefined ? (line.cuves + ' cuve' + (line.cuves > 1 ? 's' : '')) : ''}</span>
                    </div>
                    <button class='bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded' onclick='removeLoadingLine(${idx})'>Supprimer</button>
                </div>`;
            }).join('');
            renderLoadingPlan();
            setupLoadingLineInputs();
            setupLoadingLineClicks();
        }
        function setupLoadingLineClicks() {
            document.querySelectorAll('.loading-line').forEach(div => {
                div.onclick = async function(e) {
                    // Si déjà un client sélectionné, ne rien faire
                    const idx = +div.dataset.idx;
                    if (window.loadingLinesData[idx].client) return;
                    // Récupérer tous les clients disponibles dans le stock
                    const clientsInStock = [];
                    stockEntries.forEach(e => {
                        if (!clientsInStock.some(c => c.code === e.clientCode)) {
                            clientsInStock.push({ code: e.clientCode, name: e.clientName });
                        }
                    });
                    if (!clientsInStock.length) return;
                    // Afficher une popup de sélection
                    const options = clientsInStock.map(c => `<div class='px-4 py-2 hover:bg-blue-100 cursor-pointer' data-code='${c.code}' data-name='${c.name}'><b>${c.code}</b> - <b>${c.name}</b></div>`).join('');
                    let popupDiv = document.getElementById('loadingClientPopup');
                    if (!popupDiv) {
                        popupDiv = document.createElement('div');
                        popupDiv.id = 'loadingClientPopup';
                        popupDiv.className = 'fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-50';
                        popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-xs w-full mx-4'><div class='font-bold mb-2 text-lg'>Clients disponibles</div><div id='loadingClientPopupList'></div><button id='closeLoadingClientPopup' class='mt-4 bg-gray-400 hover:bg-gray-500 text-white px-4 py-2 rounded'>Annuler</button></div>`;
                        document.body.appendChild(popupDiv);
                    }
                    document.getElementById('loadingClientPopupList').innerHTML = options;
                    popupDiv.style.display = '';
                    document.getElementById('closeLoadingClientPopup').onclick = function() { popupDiv.style.display = 'none'; };
                    document.querySelectorAll('#loadingClientPopupList > div').forEach(opt => {
                        opt.onclick = function() {
                            const code = opt.dataset.code;
                            const name = opt.dataset.name;
                            window.loadingLinesData[idx].client = `${code} ${name}`;
                            popupDiv.style.display = 'none';
                            updateCuvesForLine(idx);
                            renderLoadingLines();
                        };
                    });
                };
            });
        }
        window.addLoadingLine = function() {
            window.loadingLinesData.push({ client: '', date: '', cuves: undefined });
            renderLoadingLines();
        };
        window.removeLoadingLine = function(idx) {
            window.loadingLinesData.splice(idx, 1);
            renderLoadingLines();
        };
        document.getElementById('addLoadingLine').onclick = window.addLoadingLine;
        function setupLoadingLineInputs() {
            document.querySelectorAll('.clientInput').forEach(input => {
                input.oninput = function(e) {
                    const idx = +e.target.dataset.idx;
                    window.loadingLinesData[idx].client = e.target.value;
                    updateCuvesForLine(idx);
                };
                input.onfocus = function(e) {
                    showClientSuggestionsForLoading(e.target);
                };
            });
            document.querySelectorAll('.dateInput').forEach(input => {
                input.oninput = function(e) {
                    const idx = +e.target.dataset.idx;
                    window.loadingLinesData[idx].date = e.target.value;
                    updateCuvesForLine(idx);
                };
            });
        }
        function updateCuvesForLine(idx) {
            const line = window.loadingLinesData[idx];
            // Extraire code client si possible
            let code = (line.client || '').split(' ')[0];
            if (!clients[code]) {
                // Essayer de retrouver le code par nom
                for (const [c, n] of Object.entries(clients)) {
                    if (n.toLowerCase() === (line.client || '').toLowerCase()) code = c;
                }
            }
            // Chercher les cuves correspondantes
            const cuves = stockEntries.filter(e => {
                return (e.clientCode == code || e.clientName.toLowerCase().includes((line.client || '').toLowerCase())) &&
                    formatDateFr(parseDateTime(e.dateTime)) === (line.date || '').trim();
            });
            line.cuves = cuves.reduce((sum, e) => sum + (e.quantity || 0), 0);
            renderLoadingLines();
        }
        function renderLoadingPlan() {
            const planDiv = document.getElementById('loadingPlan');
            if (!planDiv) return;
            if (!window.loadingLinesData.length) {
                planDiv.innerHTML = '';
                return;
            }
            planDiv.innerHTML = `<h3 class='font-bold mb-2'>Plan de chargement</h3>` +
                window.loadingLinesData.map((line, idx) =>
                    `<div class='mb-1 p-2 bg-white rounded shadow border flex flex-col md:flex-row md:items-center gap-2'>
                        <span class='font-semibold text-blue-700'>${line.client || ''}</span>
                        <span class='text-gray-600 text-xs'>${line.date || ''}</span>
                        <span class='text-gray-700 text-sm'>${line.cuves !== undefined ? (line.cuves + ' cuve' + (line.cuves > 1 ? 's' : '')) : ''}</span>
                    </div>`
                ).join('');
        }
        // Suggestions client pour la page chargement
        function showClientSuggestionsForLoading(input) {
            let suggestionsDiv = document.getElementById('loadingClientSuggestions');
            if (!suggestionsDiv) {
                suggestionsDiv = document.createElement('div');
                suggestionsDiv.id = 'loadingClientSuggestions';
                suggestionsDiv.className = 'absolute z-50 bg-white border border-gray-300 rounded-lg shadow-lg mt-1 w-40';
                document.body.appendChild(suggestionsDiv);
            }
            const value = input.value.trim().toUpperCase();
            if (!value) {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.add('hidden');
                return;
            }
            let suggestions = [];
            Object.entries(clients).forEach(([code, name]) => {
                if (code.toUpperCase().includes(value) || name.toUpperCase().includes(value)) {
                    suggestions.push({ code, name });
                }
            });
            if (suggestions.length > 0) {
                suggestionsDiv.innerHTML = suggestions.map(s => `<div class='px-4 py-2 hover:bg-blue-100 cursor-pointer' data-code='${s.code}' data-name='${s.name}'><b>${s.code}</b> - <b>${s.name}</b></div>`).join('');
                suggestionsDiv.classList.remove('hidden');
                const rect = input.getBoundingClientRect();
                suggestionsDiv.style.position = 'fixed';
                suggestionsDiv.style.left = rect.left + 'px';
                suggestionsDiv.style.width = rect.width + 'px';
                suggestionsDiv.style.top = (rect.bottom + 2) + 'px';
                suggestionsDiv.style.zIndex = 1000;
                suggestionsDiv.onclick = function(e) {
                    let target = e.target;
                    while (target && !target.dataset.code && target !== suggestionsDiv) {
                        target = target.parentElement;
                    }
                    if (target && target.dataset && target.dataset.code) {
                        input.value = `${target.dataset.code} ${target.dataset.name}`;
                        const idx = +input.dataset.idx;
                        window.loadingLinesData[idx].client = `${target.dataset.code} ${target.dataset.name}`;
                        suggestionsDiv.classList.add('hidden');
                        updateCuvesForLine(idx);
                        setTimeout(() => {
                            const dateInput = document.querySelector(`.dateInput[data-idx='${idx}']`);
                            if (dateInput) dateInput.focus();
                        }, 0);
                    }
                };
            } else {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.add('hidden');
            }
            input.onblur = function() {
                setTimeout(() => suggestionsDiv.classList.add('hidden'), 150);
            };
            input.onfocus = function() {
                if (suggestionsDiv.innerHTML) suggestionsDiv.classList.remove('hidden');
            };
        }
        // Initialiser la page vide
        window.loadingLinesData = [];
        renderLoadingLines();

        // 1. Supprimer le bouton 'Chargement' de la navigation
        const loadingTabBtn = document.getElementById('loadingTab');
        if (loadingTabBtn) loadingTabBtn.remove();
        // 2. Supprimer le contenu de l'onglet 'Chargement'
        const loadingTabContent = document.getElementById('loadingTabContent');
        if (loadingTabContent) loadingTabContent.remove();
        // 3. Supprimer les fonctions et variables JS associées à la page 'Chargement'
        window.loadingLinesData = undefined;
        window.loadingOrder = undefined;
        window.addLoadingLine = undefined;
        window.removeLoadingLine = undefined;
        window.moveLoadingClient = undefined;
        if (window.setActiveTab) {
            // Restaurer la version d'origine si elle existe
            if (window._oldSetActiveTab) window.setActiveTab = window._oldSetActiveTab;
        }

       
     
        if (navDiv && !document.getElementById('searchCuveTab')) {
            const searchCuveBtn = document.createElement('button');
            searchCuveBtn.id = 'searchCuveTab';
            searchCuveBtn.className = 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
            searchCuveBtn.innerHTML = '🔎 Recherche de cuves';
            searchCuveBtn.onclick = function() { setActiveTab('searchCuve'); };
            navDiv.appendChild(searchCuveBtn);
        }
        if (!document.getElementById('searchCuveTabContent')) {
            const searchCuveTabContent = document.createElement('div');
            searchCuveTabContent.id = 'searchCuveTabContent';
            searchCuveTabContent.className = 'bg-white rounded-lg shadow p-6 hidden';
            searchCuveTabContent.innerHTML = `
                <h2 class='text-2xl font-bold mb-6'>Recherche de cuves</h2>
                <div class='mb-4'>
                    <label class='block text-sm font-bold text-gray-700 mb-2'>Numéro de cuve</label>
                    <input type='text' id='searchCuveInput' placeholder='Numéro de cuve...' class='w-full p-3 border-2 border-gray-300 rounded-lg text-lg' autocomplete='off' />
                </div>
                <button id='searchCuveBtn' class='bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded font-bold text-base'>Rechercher</button>
                <div id='searchCuveResult' class='mt-6'></div>
            `;
            document.getElementById('mainApp').appendChild(searchCuveTabContent);
        }
        // Gestion de l'affichage des onglets (3 onglets)
        const _oldSetActiveTab_searchCuve = window.setActiveTab || function(){};
        window.setActiveTab = function(tab) {
            activeTab = tab;
            document.getElementById('addTabContent').classList.toggle('hidden', tab !== 'add');
            document.getElementById('stockTabContent').classList.toggle('hidden', tab !== 'stock');
            document.getElementById('searchCuveTabContent').classList.toggle('hidden', tab !== 'searchCuve');
            document.getElementById('addTab').className = tab === 'add'
                ? 'flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white'
                : 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
            document.getElementById('stockTab').className = tab === 'stock'
                ? 'flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white'
                : 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
            document.getElementById('searchCuveTab').className = tab === 'searchCuve'
                ? 'flex-1 py-3 px-6 rounded-lg font-medium text-lg bg-blue-500 text-white'
                : 'flex-1 py-3 px-6 rounded-lg font-medium text-lg text-gray-600 hover:bg-gray-100';
            if (tab === 'stock') updateStockView();
        };
        // Logique de recherche de cuve
        const searchCuveInput = document.getElementById('searchCuveInput');
        const searchCuveBtn = document.getElementById('searchCuveBtn');
        const searchCuveResult = document.getElementById('searchCuveResult');
        if (searchCuveBtn) {
            searchCuveBtn.onclick = function() {
                const searchTerm = (searchCuveInput.value || '').trim().toLowerCase();
                if (!searchTerm) {
                    searchCuveResult.innerHTML = '<div class="text-red-500">Veuillez entrer un numéro de cuve.</div>';
                    return;
                }
                let foundCuves = [];
                for (const entry of stockEntries) {
                    if (entry.cuveIds) {
                        for (let i = 0; i < entry.cuveIds.length; i++) {
                            const id = entry.cuveIds[i];
                            if (id && id.toLowerCase().includes(searchTerm)) {
                                foundCuves.push({
                                    entry,
                                    cuveId: id,
                                    cuveIdx: i,
                                    line: entry.lines && entry.lines.length ? entry.lines[0] : '-',
                                });
                            }
                        }
                    }
                }
                if (foundCuves.length) {
                    // Si un seul résultat, on ajoute un bouton 'Voir dans Stock'
                    if (foundCuves.length === 1) {
                        const f = foundCuves[0];
                        let btnPrelevement = '';
                        let btnVoirStock = '';
                        let lineLabel = (f.line === 0) ? 'en prélèvement' : f.line;
                        if (f.line !== 0) {
                            btnPrelevement = `<button class='mt-2 bg-pink-500 hover:bg-pink-600 text-white px-3 py-1 rounded font-bold text-xs' onclick='window.moveCuveToPrelevement("${f.cuveId}")'>Mettre en prélèvement</button>`;
                            btnVoirStock = `<button class='mt-2 ml-2 bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded font-bold text-xs' onclick='window.goToStockAndHighlightCuve("${f.cuveId}")'>Voir dans Stock</button>`;
                        }
                        searchCuveResult.innerHTML = `
                            <div id='uniqueCuveResult' class='border rounded-lg p-4 bg-blue-50 mb-2'>
                                <div class='font-bold text-lg mb-2'>${f.entry.clientName} (${f.entry.clientCode})</div>
                                <div class='text-sm text-gray-700'>
                                    <b>ID cuve :</b> ${f.cuveId}<br>
                                    <b>Quantité :</b> 1<br>
                                    <b>Ligne :</b> ${lineLabel}<br>
                                    <b>Date/Heure :</b> ${formatDateFr(parseDateTime(f.entry.dateTime))}
                                </div>
                                <div class='flex flex-row gap-2 mt-2'>
                                ${btnPrelevement}
                                    ${btnVoirStock}
                                </div>
                            </div>
                        `;
                        window.goToStockAndHighlightCuve = function(cuveId) {
                            setActiveTab('stock');
                            setTimeout(() => {
                                // Surligne la ligne correspondante dans Stock actuel
                                const stockBlocks = document.querySelectorAll('#stockSearchResults > div.border, #stockSearchResults .border');
                                let found = false;
                                stockBlocks.forEach(block => {
                                    if (block.innerHTML.includes(cuveId)) {
                                        block.classList.add('bg-yellow-200');
                                        block.scrollIntoView({behavior:'smooth', block:'center'});
                                        found = true;
                                        setTimeout(() => block.classList.remove('bg-yellow-200'), 2500);
                                    }
                                });
                                if (!found) {
                                    const allBlocks = document.querySelectorAll('#stockTabContent .border');
                                    allBlocks.forEach(block => {
                                        if (block.innerHTML.includes(cuveId)) {
                                            block.classList.add('bg-yellow-200');
                                            block.scrollIntoView({behavior:'smooth', block:'center'});
                                            setTimeout(() => block.classList.remove('bg-yellow-200'), 2500);
                                        }
                                    });
                                }
                            }, 200);
                            // Réinitialise la recherche
                            searchCuveInput.value = '';
                            searchCuveResult.innerHTML = '';
                        };
                        return;
                    }
                    // ... code existant pour plusieurs résultats ...
                } else {
                    searchCuveResult.innerHTML = `<div class='text-red-500'>Aucune cuve trouvée avec ce numéro.</div>`;
                }
            };
        }

        // Sauvegarde automatique du stock dans le navigateur (localStorage)
        function saveStockToLocal() {
            try {
                localStorage.setItem('cuves_stock', JSON.stringify(stockEntries));
            } catch (e) { console.error('Erreur sauvegarde stock', e); }
        }
        function loadStockFromLocal() {
            try {
                const data = localStorage.getItem('cuves_stock');
                if (data) stockEntries = JSON.parse(data);
            } catch (e) { console.error('Erreur chargement stock', e); }
        }
        // Charger le stock au démarrage
        loadStockFromLocal();
        // Sauvegarder après chaque modification
        function updateStockViewAndSave() {
            updateStockView();
            saveStockToLocal();
            if (typeof generateLinesGrid === 'function') generateLinesGrid();
        }

        // Ajout d'une page de connexion simple
        if (!document.getElementById('loginScreen')) {
            const loginDiv = document.createElement('div');
            loginDiv.id = 'loginScreen';
            loginDiv.className = 'fixed inset-0 flex items-center justify-center bg-gray-100 z-50';
            loginDiv.innerHTML = `
                <div class='bg-white rounded-lg shadow-lg p-8 max-w-xs w-full flex flex-col gap-4'>
                    <h2 class='text-2xl font-bold text-center mb-2'>Connexion</h2>
                    <input id='loginUser' type='text' placeholder='Identifiant' class='w-full p-3 border-2 border-gray-300 rounded-lg text-lg' autocomplete='username' />
                    <input id='loginPass' type='password' placeholder='Mot de passe' class='w-full p-3 border-2 border-gray-300 rounded-lg text-lg' autocomplete='current-password' />
                    <button id='loginBtn' class='bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded font-bold text-base'>Se connecter</button>
                    <div id='loginError' class='text-red-500 text-center text-sm mt-2'></div>
                </div>
            `;
            document.body.appendChild(loginDiv);
            document.getElementById('mainApp').style.filter = 'blur(4px)';
            document.getElementById('mainApp').style.pointerEvents = 'none';
            document.getElementById('loginBtn').onclick = function() {
                const user = document.getElementById('loginUser').value.trim();
                const pass = document.getElementById('loginPass').value.trim();
                if ((user === 'lapin' && pass === 'lapin') || (user === 'fred' && pass === 'fred')) {
                    loginDiv.remove();
                    document.getElementById('mainApp').style.filter = '';
                    document.getElementById('mainApp').style.pointerEvents = '';
                } else {
                    document.getElementById('loginError').textContent = 'Identifiant ou mot de passe incorrect.';
                }
            };
            document.getElementById('loginPass').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') document.getElementById('loginBtn').click();
            });
        }

        // Recherche de cuves en temps réel avec suggestions
        if (searchCuveInput) {
            searchCuveInput.oninput = function() {
                const searchTerm = (searchCuveInput.value || '').trim().toLowerCase();
                if (!searchTerm) {
                    searchCuveResult.innerHTML = '';
                    if (document.getElementById('searchCuveSuggestions')) document.getElementById('searchCuveSuggestions').remove();
                    return;
                }
                // Suggestions (inchangé)
                // ...
                // Affichage infos cuve en temps réel (modifié)
                let foundCuves = [];
                for (const entry of stockEntries) {
                    if (entry.cuveIds) {
                        for (let i = 0; i < entry.cuveIds.length; i++) {
                            const id = entry.cuveIds[i];
                            if (id && id.toLowerCase().includes(searchTerm)) {
                                foundCuves.push({
                                    entry,
                                    cuveId: id,
                                    cuveIdx: i,
                                    line: entry.lines && entry.lines.length ? entry.lines[0] : '-',
                                });
                            }
                        }
                    }
                }
                if (foundCuves.length) {
                    searchCuveResult.innerHTML = foundCuves.map(f => {
                        let btnPrelevement = '';
                        let lineLabel = (f.line === 0) ? 'en prélèvement' : f.line;
                        if (f.line !== 0) {
                            btnPrelevement = `<button class='mt-2 bg-pink-500 hover:bg-pink-600 text-white px-3 py-1 rounded font-bold text-xs' onclick='window.moveCuveToPrelevement("${f.cuveId}")'>Mettre en prélèvement</button>`;
                        }
                        return `
                            <div class='border rounded-lg p-4 bg-blue-50 mb-2'>
                                <div class='font-bold text-lg mb-2'>${f.entry.clientName} (${f.entry.clientCode})</div>
                                <div class='text-sm text-gray-700'>
                                    <b>ID cuve :</b> ${f.cuveId}<br>
                                    <b>Quantité :</b> 1<br>
                                    <b>Ligne :</b> ${lineLabel}<br>
                                    <b>Date/Heure :</b> ${formatDateFr(parseDateTime(f.entry.dateTime))}
                                </div>
                                ${btnPrelevement}
                            </div>
                        `;
                    }).join('');
                } else {
                    searchCuveResult.innerHTML = `<div class='text-red-500'>Aucune cuve trouvée avec ce numéro.</div>`;
                }
            };
            // ... existing code ...
            if (searchCuveBtn) {
                searchCuveBtn.onclick = function() {
                    const suggDiv = document.getElementById('searchCuveSuggestions');
                    if (suggDiv) suggDiv.style.display = 'none';
                    // ... code existant ...
                    const searchTerm = (searchCuveInput.value || '').trim().toLowerCase();
                    if (!searchTerm) {
                        searchCuveResult.innerHTML = '<div class="text-red-500">Veuillez entrer un numéro de cuve.</div>';
                        return;
                    }
                    let foundCuves = [];
                    for (const entry of stockEntries) {
                        if (entry.cuveIds) {
                            for (let i = 0; i < entry.cuveIds.length; i++) {
                                const id = entry.cuveIds[i];
                                if (id && id.toLowerCase().includes(searchTerm)) {
                                    foundCuves.push({
                                        entry,
                                        cuveId: id,
                                        cuveIdx: i,
                                        line: entry.lines && entry.lines.length ? entry.lines[0] : '-',
                                    });
                                }
                            }
                        }
                    }
                    if (foundCuves.length) {
                        searchCuveResult.innerHTML = foundCuves.map(f => {
                            let btnPrelevement = '';
                            let lineLabel = (f.line === 0) ? 'en prélèvement' : f.line;
                            if (f.line !== 0) {
                                btnPrelevement = `<button class='mt-2 bg-pink-500 hover:bg-pink-600 text-white px-3 py-1 rounded font-bold text-xs' onclick='window.moveCuveToPrelevement("${f.cuveId}")'>Mettre en prélèvement</button>`;
                            }
                            return `
                                <div class='border rounded-lg p-4 bg-blue-50 mb-2'>
                                    <div class='font-bold text-lg mb-2'>${f.entry.clientName} (${f.entry.clientCode})</div>
                                    <div class='text-sm text-gray-700'>
                                        <b>ID cuve :</b> ${f.cuveId}<br>
                                        <b>Quantité :</b> 1<br>
                                        <b>Ligne :</b> ${lineLabel}<br>
                                        <b>Date/Heure :</b> ${formatDateFr(parseDateTime(f.entry.dateTime))}
                                    </div>
                                    ${btnPrelevement}
                                </div>
                            `;
                        }).join('');
                    } else {
                        searchCuveResult.innerHTML = `<div class='text-red-500'>Aucune cuve trouvée avec ce numéro.</div>`;
                    }
                };
            }
        }

        // Juste après la fonction removeTanksForClientOnLine, ajouter la fonction de transfert :

        async function transferTanksForClientOnLine(clientName, fromLine) {
            // Trouver l'entrée à transférer
            const entry = stockEntries.find(entry => entry.clientName === clientName && entry.lines.includes(fromLine));
            if (!entry) return;
            // Générer la liste des lignes disponibles (pas pleines, pas la ligne actuelle)
            const availableLines = [];
            for (let l = 1; l <= 14; l++) {
                if (l === fromLine) continue;
                const info = getLineInfo(l);
                if (info.quantity + entry.quantity <= 22) availableLines.push(l);
            }
            if (availableLines.length === 0) {
                await showPopup({
                    title: 'Aucune ligne disponible',
                    message: 'Aucune ligne n\'a assez de place pour ce transfert.',
                    icon: '⚠️'
                });
                return;
            }
            // Afficher une popup pour choisir la ligne
            let optionsHtml = availableLines.map(l => `<button class='bg-blue-100 hover:bg-blue-200 text-blue-700 font-bold px-3 py-2 rounded m-1' onclick='window._doTransferClientLine(${fromLine},${l},"${clientName.replace(/'/g, "\\'")}")'>Ligne ${l}</button>`).join('');
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-xs w-full mx-4'><div class='font-bold mb-2 text-lg'>Transférer ${clientName}</div><div class='mb-4'>Choisissez la ligne de destination :</div><div class='flex flex-wrap'>${optionsHtml}</div><button class='mt-4 bg-gray-400 hover:bg-gray-500 text-white px-4 py-2 rounded' id='cancelTransferBtn'>Annuler</button></div>`;
            document.body.appendChild(popupDiv);
            document.getElementById('cancelTransferBtn').onclick = () => popupDiv.remove();
            // Fonction globale temporaire pour gérer le transfert
            window._doTransferClientLine = async function(from, to, client) {
                // Vérifier à nouveau la capacité
                const entry = stockEntries.find(entry => entry.clientName === client && entry.lines.includes(from));
                if (!entry) return;
                const info = getLineInfo(to);
                if (info.quantity + entry.quantity > 22) {
                    await showPopup({
                        title: 'Capacité insuffisante',
                        message: `La ligne ${to} n\'a pas assez de place.`,
                        icon: '⚠️'
                    });
                    popupDiv.remove();
                    return;
                }
                // Mettre à jour la ligne de l'entrée
                entry.lines = [to];
                updateStockViewAndSave();
                popupDiv.remove();
                await showPopup({
                    title: 'Transfert effectué',
                    message: `${client} a été transféré en ligne ${to}.`,
                    icon: '✅'
                });
            };
        }

        // Ajoute la fonction showLineDetailsPopup dans le script :
        function showLineDetailsPopup(line) {
            const entries = stockEntries.filter(e => e.lines && e.lines.includes(line));
            const info = getLineInfo(line);
            let html = `<div class='font-bold text-lg mb-2'>Ligne ${line}</div>`;
            html += `<div class='mb-2 text-sm'>Capacité restante : <b>${info.remainingCapacity}</b> / 22</div>`;
            if (entries.length === 0) {
                html += `<div class='text-gray-500'>Aucune cuve sur cette ligne.</div>`;
            } else {
                entries.forEach(e => {
                    html += `<div class='mb-2 p-2 bg-blue-50 rounded'>
                        <div class='font-bold'>${e.clientName || ''} (${e.clientCode || ''})</div>
                        <div class='text-xs text-gray-700'><b>Quantité :</b> ${e.quantity || 1}</div>
                        <div class='text-xs text-gray-700'><b>ID(s) cuve :</b> ${(e.cuveIds || []).join(', ')}</div>
                        <div class='text-xs text-gray-700'><b>Date/Heure :</b> ${formatDateFr(parseDateTime(e.dateTime))}</div>
                        <div class='text-xs text-gray-700'><b>Ajouté par :</b> ${e.user || 'N/A'}</div>
                    </div>`;
                });
            }
            // Popup custom
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-md w-full mx-4 relative'>
                <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(".fixed").remove()'>&times;</button>
                ${html}
            </div>`;
            document.body.appendChild(popupDiv);
        }

        function completeRow() {
            let html = `<div class='mb-2 font-bold'>Compléter une ligne</div>`;
            html += `<label class='block mb-1'>Sélectionner la ligne à compléter (destination)</label>`;
            html += `<div id='completeRowDestGrid' class='grid grid-cols-2 md:grid-cols-7 gap-1 w-full mb-3'></div>`;
            html += `<label class='block mb-1'>Sélectionner une ligne à vider (source)</label>`;
            html += `<div id='completeRowSourceGrid' class='grid grid-cols-2 md:grid-cols-7 gap-1 w-full mb-3'></div>`;
            html += `<div id='completeRowClientsContainer'></div>`;
            html += `<div class='flex gap-2'>`;
            html += `<button id='completeRowDoBtn' class='bg-blue-500 hover:bg-blue-600 text-white font-bold px-4 py-2 rounded w-full' disabled>Déplacer</button>`;
            html += `<button id='completeRowCancelBtn' class='bg-gray-400 hover:bg-gray-500 text-white font-bold px-4 py-2 rounded w-full'>Annuler</button>`;
            html += `</div>`;
            html += `<div id='completeRowActions'></div>`;
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-md w-full mx-4 relative'>
                <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(\".fixed\").remove()'>&times;</button>
                ${html}
            </div>`;
            document.body.appendChild(popupDiv);
            const destGrid = popupDiv.querySelector('#completeRowDestGrid');
            const sourceGrid = popupDiv.querySelector('#completeRowSourceGrid');
            const clientsContainer = popupDiv.querySelector('#completeRowClientsContainer');
            const doBtn = popupDiv.querySelector('#completeRowDoBtn');
            const cancelBtn = popupDiv.querySelector('#completeRowCancelBtn');
            const actionsDiv = popupDiv.querySelector('#completeRowActions');
            let selectedDest = null;
            let selectedSource = null;
            let selectedClients = [];
            let clientsOrder = [];

            function renderDestGrid() {
                destGrid.innerHTML = '';
                for (let l = 1; l <= 14; l++) {
                    const info = getLineInfo(l);
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'flex flex-col items-center justify-center rounded border font-bold text-sm cursor-pointer shadow transition-all duration-200 min-w-[60px] min-h-[60px] p-1 ' +
                        (selectedDest === l ? 'bg-green-500 text-white border-green-700' : info.quantity < 22 ? 'bg-white border-gray-300' : 'bg-gray-100 border-gray-200 cursor-not-allowed');
                    btn.innerHTML = `<div class='text-lg font-bold mb-1'>${l}</div>`;
                    if (info.quantity > 0) {
                        btn.innerHTML += `<div class=\"text-xs text-orange-600\">${info.quantity}/22</div>`;
                    }
                    btn.onclick = function() {
                        if (info.quantity < 22) {
                            selectedDest = l;
                            renderDestGrid();
                            renderSourceGrid();
                            updateClientsSelect();
                            updateDoBtn();
                        }
                    };
                    btn.disabled = info.quantity === 22;
                    destGrid.appendChild(btn);
                }
            }

            function renderSourceGrid() {
                sourceGrid.innerHTML = '';
                for (let l = 1; l <= 14; l++) {
                    if (l === selectedDest) continue;
                    const info = getLineInfo(l);
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'flex flex-col items-center justify-center rounded border font-bold text-sm cursor-pointer shadow transition-all duration-200 min-w-[60px] min-h-[60px] p-1 ' +
                        (selectedSource === l ? 'bg-blue-500 text-white border-blue-700' : info.quantity > 0 ? 'bg-green-200 border-green-500' : 'bg-gray-100 border-gray-200 cursor-not-allowed');
                    btn.innerHTML = `<div class='text-lg font-bold mb-1'>${l}</div>`;
                    if (info.quantity > 0) {
                        btn.innerHTML += `<div class=\"text-xs text-orange-600\">${info.quantity}/22</div>`;
                    }
                    btn.onclick = function() {
                        if (info.quantity > 0) {
                            selectedSource = l;
                            renderSourceGrid();
                            updateClientsSelect();
                            updateDoBtn();
                        }
                    };
                    btn.disabled = info.quantity === 0;
                    sourceGrid.appendChild(btn);
                }
            }

            function updateClientsSelect() {
                clientsContainer.innerHTML = '';
                selectedClients = [];
                clientsOrder = [];
                if (!(selectedSource >= 1 && selectedSource <= 14)) return;
                // Cherche tous les clients présents sur la ligne source, triés par date/heure croissante (FIFO, plus ancien en haut)
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(selectedSource));
                // Trie par date/heure croissante (le plus ancien en haut, le plus récent en bas)
                const sorted = entries.slice().sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));
                clientsOrder = Array.from(new Set(sorted.map(e => e.clientCode)));
                // Schéma d'allée pour la ligne à vider
                clientsContainer.innerHTML += `<div class='mb-2'><b>Schéma de la ligne à vider (emplacements 1 à 11, fond → devant)</b></div>`;
                clientsContainer.innerHTML += renderAisleSchema(selectedSource, sorted);
                if (clientsOrder.length > 0) {
                    let html = `<label class='block mb-1 mt-2'>Sélectionner le(s) client(s) à déplacer (ordre du plus ancien au plus récent)</label>`;
                    html += `<div class='flex flex-col gap-1 mb-3'>`;
                    clientsOrder.forEach((code, idx) => {
                        const name = entries.find(e => e.clientCode === code)?.clientName || code;
                        let mention = '';
                        if (idx === 0) {
                            mention = '— Client au fond de la ligne (premier mis, accessible)';
                        } else if (idx === clientsOrder.length - 1) {
                            mention = '— Client devant la ligne (dernier ajouté, non accessible tant que les autres ne sont pas déplacés)';
                        } else {
                            mention = `— ${idx + 1}ème client à déplacer`;
                        }
                        html += `<label class='inline-flex items-center'><input type='checkbox' class='form-checkbox mr-2' value='${code}'>${code} - ${name} <span class='text-xs text-gray-500 ml-2'>${mention}</span></label>`;
                    });
                    html += `</div>`;
                    clientsContainer.innerHTML += html;
                    // Gestion de la sélection continue depuis le fond
                    const checkboxes = Array.from(clientsContainer.querySelectorAll('input[type=checkbox]'));
                    checkboxes.forEach((cb, idx) => {
                        cb.onchange = function() {
                            // Si on décoche un client, décocher tous ceux devant (plus récents)
                            if (!cb.checked) {
                                for (let i = idx + 1; i < checkboxes.length; i++) {
                                    checkboxes[i].checked = false;
                                }
                            } else {
                                // Si on coche un client, cocher tous ceux au fond (plus anciens)
                                for (let i = 0; i < idx; i++) {
                                    checkboxes[i].checked = true;
                                }
                            }
                            selectedClients = checkboxes.filter(c => c.checked).map(c => c.value);
                            updateDoBtn();
                            };
                        });
                    }
            }

            function updateDoBtn() {
                let enable = (selectedDest && selectedSource && selectedDest !== selectedSource && selectedClients.length > 0);
                doBtn.disabled = !enable;
                actionsDiv.innerHTML = '';
            }

            renderDestGrid();
            renderSourceGrid();

            doBtn.onclick = function() {
                const dest = selectedDest;
                const src = selectedSource;
                if (!(dest >= 1 && dest <= 14 && src >= 1 && src <= 14 && dest !== src && selectedClients.length > 0)) return;
                // Cherche tous les clients présents sur la ligne source, triés par date/heure croissante (FIFO, plus ancien en haut)
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(src));
                const sorted = entries.slice().sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));
                // Pour chaque client sélectionné, dans l'ordre du plus ancien au plus récent, déplacer ses cuves
                const destInfo = getLineInfo(dest);
                let capacityLeft = 22 - destInfo.quantity;
                for (const clientCode of clientsOrder) {
                    if (!selectedClients.includes(clientCode)) continue;
                    // On prend toutes les entrées de ce client sur la ligne source, dans l'ordre FIFO (plus ancien au fond)
                    const clientEntries = sorted.filter(e => e.clientCode === clientCode);
                    for (const entry of clientEntries) {
                        const qtyToMove = Math.min(entry.quantity, capacityLeft);
                        if (qtyToMove <= 0) break;
                        // Crée ou fusionne une entrée sur la ligne destination
                        let destEntry = stockEntries.find(e => e.clientCode === entry.clientCode && e.dateTime === entry.dateTime && e.lines.includes(dest));
                        if (!destEntry) {
                            destEntry = { ...entry, lines: [dest], quantity: 0, cuveIds: [] };
                            stockEntries.push(destEntry);
                        }
                        // Déplace les cuves (toujours à la fin pour respecter l'ordre FIFO)
                        const movedCuves = entry.cuveIds.splice(0, qtyToMove);
                        destEntry.cuveIds = (destEntry.cuveIds || []).concat(movedCuves);
                        destEntry.quantity += qtyToMove;
                        entry.quantity -= qtyToMove;
                    if (entry.quantity <= 0 || entry.cuveIds.length === 0) {
                        const idx = stockEntries.indexOf(entry);
                        if (idx !== -1) stockEntries.splice(idx, 1);
                    }
                        capacityLeft -= qtyToMove;
                        if (capacityLeft <= 0) break;
                    }
                    if (capacityLeft <= 0) break;
                }
                updateStockViewAndSave();
                if (typeof generateLinesGrid === 'function') generateLinesGrid();
                document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                showPopup({
                    title: 'Transfert effectué',
                    message: `Les cuves des clients sélectionnés ont été transférées de la ligne ${src} vers la ligne ${dest} (ordre du plus ancien au plus récent).`,
                    icon: '✅'
                });
            };
            cancelBtn.onclick = function() {
                document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
            };
        }

        // Ajoute la fonction showPrelevementReturnPopup
        function showPrelevementReturnPopup(cuveId) {
            // Trouver l'entrée
            const entry = stockEntries.find(e => e.cuveIds && e.cuveIds.includes(cuveId) && e.lines && e.lines.includes(0));
            if (!entry) return;
            // Chercher une ligne avec même client ET même date/heure
            let sameLine = null;
            for (let l = 1; l <= 14; l++) {
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(l));
                for (const e2 of entries) {
                    if (e2.clientCode === entry.clientCode && e2.dateTime === entry.dateTime) {
                        sameLine = l;
                        break;
                    }
                }
                if (sameLine) break;
            }
            // Proposer les lignes disponibles
            let availableLines = [];
            for (let l = 1; l <= 14; l++) {
                const info = getLineInfo(l);
                if (info.quantity < 22) availableLines.push(l);
            }
            // Si une ligne correspondante existe, la proposer en premier
            let html = `<div class='mb-2 font-bold'>Où remettre la cuve <b>${cuveId}</b> (${entry.clientName}) ?</div>`;
            if (sameLine) {
                html += `<button class='bg-green-500 hover:bg-green-600 text-white font-bold px-4 py-2 rounded m-1 mb-3' onclick='window._doReturnFromPrelevement("${cuveId}",${sameLine})'>Ligne ${sameLine} (même client/date/heure)</button>`;
            }
            // Si pas de ligne correspondante, ou pour proposer d'autres lignes libres
            let otherLines = availableLines.filter(l => l !== sameLine);
            if (!sameLine && !otherLines.length) {
                html += `<div class='text-red-500'>Aucune ligne disponible.</div>`;
            } else if (otherLines.length) {
                html += `<div class='mb-1 text-xs text-gray-500'>Autres lignes disponibles :</div><div class='flex flex-wrap gap-2'>` +
                    otherLines.map(l => `<button class='bg-blue-100 hover:bg-blue-200 text-blue-700 font-bold px-3 py-2 rounded m-1' onclick='window._doReturnFromPrelevement("${cuveId}",${l})'>Ligne ${l}</button>`).join('') +
                    `</div>`;
            }
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-md w-full mx-4 relative'>
                <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(".fixed").remove()'>&times;</button>
                ${html}
            </div>`;
            document.body.appendChild(popupDiv);
            window._doReturnFromPrelevement = function(cuveId, toLine) {
                const entry = stockEntries.find(e => e.cuveIds && e.cuveIds.includes(cuveId) && e.lines && e.lines.includes(0));
                if (!entry) return;
                entry.lines = [toLine];
                updateStockViewAndSave();
                document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                showPopup({
                    title: 'Remise effectuée',
                    message: `La cuve ${cuveId} a été remise en ligne ${toLine}.`,
                    icon: '✅'
                });
            };
        }

        // ... existing code ...
        window.moveCuveToPrelevement = async function(cuveId) {
            // Trouver l'entrée et l'index de la cuve
            const entry = stockEntries.find(e => e.cuveIds && e.cuveIds.includes(cuveId));
            if (!entry) return;
            const cuveIdx = entry.cuveIds.indexOf(cuveId);
            // Popup de confirmation
            const confirmed = await showPopup({
                title: 'Confirmation',
                message: `Confirmer la mise en prélèvement de la cuve ${cuveId} (${entry.clientName}) ?`,
                icon: '🧪',
                confirmText: 'Oui, prélever',
                cancelText: 'Annuler',
                showCancel: true
            });
            if (!confirmed) return;
            // Créer une nouvelle entrée en prélèvement
            stockEntries.push({
                clientCode: entry.clientCode,
                clientName: entry.clientName,
                quantity: 1,
                lines: [0],
                cuveIds: [cuveId],
                dateTime: entry.dateTime,
                user: entry.user
            });
            // Retirer la cuve de l'entrée d'origine
            entry.cuveIds.splice(cuveIdx, 1);
            entry.quantity--;
            if (entry.quantity <= 0 || entry.cuveIds.length === 0) {
                const idx = stockEntries.indexOf(entry);
                if (idx !== -1) stockEntries.splice(idx, 1);
            }
            updateStockViewAndSave();
            showPopup({
                title: 'Prélèvement',
                message: 'La cuve a été déplacée en zone prélèvement.',
                icon: '🧪'
            });
            // Rafraîchir la recherche
            if (typeof searchCuveBtn !== 'undefined') searchCuveBtn.onclick();
        };
        // ... existing code ...

        // Ajout de la fonction showDeleteClientPopup
        function showDeleteClientPopup(mode) {
            let selectedClient = null;
            let selectedDateTime = null;
            let selectedLine = null;
            let suggestions = [];
            let html = `<div class='mb-2 font-bold'>Supprimer un client d'une ligne</div>`;
            html += `<label class='block mb-1'>Code ou nom client</label>`;
            html += `<input id='deleteClientInput' type='text' class='w-full p-2 border rounded mb-3' placeholder='Code ou nom client...' autocomplete='off' />`;
            html += `<div id='deleteClientSuggestions' class='mb-2'></div>`;
            html += `<label class='block mb-1'>Date et heure</label>`;
            html += `<input id='deleteDateTimeInput' type='text' class='w-full p-2 border rounded mb-3' placeholder='JJ/MM HHh' autocomplete='off' maxlength='9' />`;
            html += `<div id='deleteDateTimeSuggestions' class='mb-2'></div>`;
            html += `<label class='block mb-1'>Ligne</label>`;
            html += `<input id='deleteLineInput' type='number' min='1' max='14' class='w-full p-2 border rounded mb-3' placeholder='Numéro de ligne' />`;
            html += `<button id='deleteClientConfirmBtn' class='bg-red-600 hover:bg-red-700 text-white font-bold px-4 py-2 rounded' disabled>Confirmer</button>`;
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-md w-full mx-4 relative'>
                <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(\".fixed\").remove()'>&times;</button>
                ${html}
            </div>`;
            document.body.appendChild(popupDiv);
            const clientInput = popupDiv.querySelector('#deleteClientInput');
            const clientSuggDiv = popupDiv.querySelector('#deleteClientSuggestions');
            const dateInput = popupDiv.querySelector('#deleteDateTimeInput');
            const dateSuggDiv = popupDiv.querySelector('#deleteDateTimeSuggestions');
            const lineInput = popupDiv.querySelector('#deleteLineInput');
            const confirmBtn = popupDiv.querySelector('#deleteClientConfirmBtn');
            // Suggestions client
            clientInput.oninput = function() {
                const val = clientInput.value.trim().toUpperCase();
                suggestions = [];
                Object.entries(clients).forEach(([code, name]) => {
                    if (code.includes(val) || name.toUpperCase().includes(val)) {
                        suggestions.push({ code, name });
                    }
                });
                if (suggestions.length) {
                    clientSuggDiv.innerHTML = suggestions.map(s => `<div class='px-4 py-2 hover:bg-blue-100 cursor-pointer rounded' data-code='${s.code}' data-name='${s.name}'>${s.code} - ${s.name}</div>`).join('');
                    clientSuggDiv.classList.remove('hidden');
                    clientSuggDiv.querySelectorAll('[data-code]').forEach(el => {
                        el.onclick = function() {
                            clientInput.value = `${el.dataset.code} ${el.dataset.name}`;
                            selectedClient = el.dataset.code;
                            clientSuggDiv.innerHTML = '';
                            updateConfirmState();
                        };
                    });
                } else {
                    clientSuggDiv.innerHTML = '';
                }
                updateConfirmState();
            };
            clientInput.onblur = function() { setTimeout(() => clientSuggDiv.classList.add('hidden'), 150); };
            clientInput.onfocus = function() { if (clientSuggDiv.innerHTML) clientSuggDiv.classList.remove('hidden'); };
            // Suggestions date/heure
            dateInput.oninput = function() {
                const val = dateInput.value.trim();
                let dateSuggestions = [];
                if (selectedClient) {
                    // Cherche toutes les dates pour ce client
                    stockEntries.forEach(e => {
                        if (e.clientCode === selectedClient && e.dateTime && !dateSuggestions.includes(e.dateTime)) {
                            dateSuggestions.push(e.dateTime);
                        }
                    });
                }
                if (dateSuggestions.length) {
                    dateSuggDiv.innerHTML = dateSuggestions.map(s => `<div class='px-4 py-2 hover:bg-blue-100 cursor-pointer rounded' data-date='${s}'>${s}</div>`).join('');
                    dateSuggDiv.classList.remove('hidden');
                    dateSuggDiv.querySelectorAll('[data-date]').forEach(el => {
                        el.onclick = function() {
                            dateInput.value = el.dataset.date;
                            selectedDateTime = el.dataset.date;
                            dateSuggDiv.innerHTML = '';
                            updateConfirmState();
                        };
                    });
                } else {
                    dateSuggDiv.innerHTML = '';
                }
                updateConfirmState();
            };
            dateInput.onblur = function() { setTimeout(() => dateSuggDiv.classList.add('hidden'), 150); };
            dateInput.onfocus = function() { if (dateSuggDiv.innerHTML) dateSuggDiv.classList.remove('hidden'); };
            // Ligne
            lineInput.oninput = updateConfirmState;
            // Activation du bouton
            function updateConfirmState() {
                selectedClient = clientInput.value.split(' ')[0];
                selectedDateTime = dateInput.value.trim();
                selectedLine = parseInt(lineInput.value);
                confirmBtn.disabled = !(selectedClient && selectedDateTime && selectedLine >= 1 && selectedLine <= 14);
            }
            // Suppression au clic
            confirmBtn.onclick = function() {
                // Supprime toutes les cuves de ce client/date/heure sur la ligne
                let before = stockEntries.length;
                stockEntries = stockEntries.filter(e => !(e.clientCode === selectedClient && e.dateTime === selectedDateTime && e.lines && e.lines.includes(selectedLine)));
                if (typeof updateStockViewAndSave === 'function') updateStockViewAndSave();
                if (typeof generateLinesGrid === 'function') generateLinesGrid();
                document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                showPopup({
                    title: 'Suppression effectuée',
                    message: before === stockEntries.length ? 'Aucune cuve trouvée pour ce client/date/ligne.' : 'Le client a été supprimé de la ligne.',
                    icon: '✅'
                });
            };
        }
        window.showDeleteClientPopup = showDeleteClientPopup;
        // ... existing code ...

        // === Chargement camion (Ajouter) ===
        window.truckLoadingData = [];
        function renderTruckLoadingList() {
            const listDiv = document.getElementById('truckLoadingList');
            if (!listDiv) return;
            listDiv.innerHTML = window.truckLoadingData.map((item, idx) => {
                // Récupère toutes les dates/heure disponibles pour ce client dans le stock
                let dateOptions = [];
                let lignesPossibles = [];
                if (item.clientCode || item.clientName) {
                    let allEntries = stockEntries.filter(e => (e.clientCode === item.clientCode || e.clientName === item.clientName));
                    dateOptions = [...new Set(allEntries.map(e => e.dateTime))];
                    // Pour la mention de ligne sélectionnée
                    lignesPossibles = allEntries.flatMap(e => e.lines || []).filter(l => l !== 0);
                }
                // Trouver le total de cuves et les lignes pour ce client/date/heure (toutes lignes confondues)
                let totalCuves = 0;
                let lignes = [];
                if (item.clientCode && item.dateTime) {
                    stockEntries.forEach(e => {
                        if (
                            (e.clientCode === item.clientCode || e.clientName === item.clientName) &&
                            e.dateTime === item.dateTime
                        ) {
                            totalCuves += e.quantity || 0;
                            if (e.lines) {
                                e.lines.forEach(l => { if (!lignes.includes(l) && l !== 0) lignes.push(l); });
                            }
                        }
                    });
                }
                let details = '';
                if (item.clientCode || item.clientName) {
                    let lignesTxt = lignes.length ? ` <span class='text-xs text-gray-500'>(lignes : ${lignes.sort((a,b)=>a-b).join(', ')})</span>` : '';
                    // Mention explicite du numéro de ligne sélectionné (si unique)
                    let mentionLigne = '';
                    if (lignes.length === 1) {
                        mentionLigne = `<span class='ml-2 text-xs text-blue-600 font-bold'>Sélectionné : ligne ${lignes[0]}</span>`;
                    }
                    details = `<div class='text-xs text-gray-700 font-bold'>${item.clientName || item.clientCode} — <b>${totalCuves}</b> cuve${totalCuves > 1 ? 's' : ''}${lignesTxt} ${mentionLigne}</div>`;
                }
                return `
                <div class='flex flex-col md:flex-row items-center gap-2 mb-2 p-2 bg-white rounded shadow truck-loading-item' data-idx='${idx}' style='cursor:pointer;'>
                    <div class='flex-1 flex flex-col md:flex-row gap-2 items-center'>
                        <input type='text' id='truckClientInput-${idx}' class='truckClientInput w-full p-4 border-2 border-gray-300 rounded-xl text-2xl mb-3' placeholder='Ex : 199, BEAUNES, 5000, CARON...' autocomplete='off' />
                        <div id='truckClientSuggestions-${idx}' class='absolute z-50 bg-white border border-gray-300 rounded-lg shadow-lg mt-1 w-full hidden'></div>
                        <select class='truckDateSelect w-32 p-2 border rounded' data-idx='${idx}'>
                            <option value=''>Heure...</option>
                            ${dateOptions.map(dt => `<option value='${dt}' ${item.dateTime === dt ? 'selected' : ''}>${formatDateFr(parseDateTime(dt))}</option>`).join('')}
                        </select>
                        ${details}
                    </div>
                    <div class='flex flex-col gap-1'>
                        <button class='px-2 py-1 bg-gray-200 rounded hover:bg-gray-300' onclick='window.moveTruckLoadingClient(${idx},-1)' ${idx === 0 ? 'disabled' : ''}>⬆️</button>
                        <button class='px-2 py-1 bg-gray-200 rounded hover:bg-gray-300' onclick='window.moveTruckLoadingClient(${idx},1)' ${idx === window.truckLoadingData.length-1 ? 'disabled' : ''}>⬇️</button>
                        <button class='px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 mt-2' onclick='window.removeTruckLoadingClient(${idx})'>🗑️</button>
                    </div>
                </div>`;
            }).join('');
        }
        window.addTruckLoadingClient = function() {
            window.truckLoadingData.push({ client: '', clientCode: '', clientName: '', dateTime: '' });
            renderTruckLoadingList();
        };
        window.removeTruckLoadingClient = function(idx) {
            window.truckLoadingData.splice(idx, 1);
            renderTruckLoadingList();
        };
        document.getElementById('addTruckLoadingClientBtn').onclick = window.addTruckLoadingClient;
        function setupTruckLoadingInputs() {
            document.querySelectorAll('.truckClientInput').forEach((input, idx) => {
                input.value = window.truckLoadingData[idx]?.client || '';
                input.oninput = function() { showClientSuggestionsTruck(`truckClientInput-${idx}`, `truckClientSuggestions-${idx}`, idx); };
            });
            document.querySelectorAll('.truckDateSelect').forEach(select => {
                select.onchange = function(e) {
                    const idx = +e.target.dataset.idx;
                    window.truckLoadingData[idx].dateTime = e.target.value;
                    renderTruckLoadingList();
                    setupTruckLoadingInputs();
                };
            });
        }
        // Rafraîchir la liste à chaque modif
        const _oldRenderTruckLoadingList = renderTruckLoadingList;
        renderTruckLoadingList = function() {
            _oldRenderTruckLoadingList.apply(this, arguments);
            setupTruckLoadingInputs();
        };
        // Initialisation
        renderTruckLoadingList();

        // Ajoute la fonction showClientSuggestionsTruck qui réutilise la logique de showClientSuggestions mais prend inputId et suggestionsDivId en paramètre :
        function showClientSuggestionsTruck(inputId, suggestionsDivId, idx) {
            const input = document.getElementById(inputId);
            const suggestionsDiv = document.getElementById(suggestionsDivId);
            const value = input.value.trim().toUpperCase();
            if (!value) {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.add('hidden');
                return;
            }
            let suggestions = [];
            Object.entries(clients).forEach(([code, name]) => {
                if (code.toUpperCase().includes(value) || name.toUpperCase().includes(value)) {
                    suggestions.push({ code, name });
                }
            });
            if (suggestions.length > 0) {
                suggestionsDiv.innerHTML = `<div style='text-align:center; font-size:18px; color:#60a5fa; margin-bottom:-6px;'>▼</div>` +
                    suggestions.map(s => `<div class='px-4 py-2 hover:bg-blue-100 cursor-pointer' data-code='${s.code}' data-name='${s.name}'><b>${s.code}</b> - <b>${s.name}</b></div>`).join('');
                suggestionsDiv.classList.remove('hidden');
                const rect = input.getBoundingClientRect();
                suggestionsDiv.style.position = 'fixed';
                suggestionsDiv.style.left = rect.left + 'px';
                suggestionsDiv.style.width = rect.width + 'px';
                suggestionsDiv.style.top = (rect.top - suggestionsDiv.offsetHeight - 8) + 'px';
                suggestionsDiv.style.bottom = 'auto';
                suggestionsDiv.style.zIndex = 1000;
                suggestionsDiv.style.background = 'white';
                suggestionsDiv.style.borderRadius = '0.5rem';
                suggestionsDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.08)';
                suggestionsDiv.style.border = '1px solid #d1d5db';
                suggestionsDiv.style.paddingTop = '0.25rem';
            } else {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.add('hidden');
            }
            suggestionsDiv.onclick = function(e) {
                let target = e.target;
                while (target && !target.dataset.code && target !== suggestionsDiv) {
                    target = target.parentElement;
                }
                if (target && target.dataset && target.dataset.code) {
                    input.value = `${target.dataset.code} ${target.dataset.name}`;
                    window.truckLoadingData[idx].client = `${target.dataset.code} ${target.dataset.name}`;
                    window.truckLoadingData[idx].clientCode = target.dataset.code;
                    window.truckLoadingData[idx].clientName = target.dataset.name;
                    suggestionsDiv.classList.add('hidden');
                    renderTruckLoadingList();
                }
            };
            input.onblur = function() {
                setTimeout(() => suggestionsDiv.classList.add('hidden'), 150);
            };
            input.onfocus = function() {
                if (suggestionsDiv.innerHTML) suggestionsDiv.classList.remove('hidden');
            };
        }

        // Ajoute la fonction showDeleteClientPopupFromStock qui appelle showDeleteClientPopup avec la bonne ligne et client :
        window.showDeleteClientPopupFromStock = function(idx) {
            const entry = stockEntries[idx];
            if (!entry) return;
            // On cherche la ligne principale (première ligne de l'entrée)
            const line = entry.lines && entry.lines.length ? entry.lines[0] : null;
            if (!line) return;
            // On appelle showDeleteClientPopup avec la ligne
            showDeleteClientPopup(line);
        };

        // Fonction utilitaire pour regrouper les entrées par client+date+heure+ligne
        function getGroupedEntries(entries) {
            const map = new Map();
            entries.forEach(e => {
                if (!e.lines) return;
                e.lines.forEach(line => {
                    const key = `${e.clientCode}|${e.clientName}|${e.dateTime}|${line}`;
                    if (!map.has(key)) {
                        map.set(key, {
                            clientCode: e.clientCode,
                            clientName: e.clientName,
                            dateTime: e.dateTime,
                            lines: [line],
                            quantity: 0,
                            cuveIds: [],
                            user: e.user
                        });
                    }
                    const obj = map.get(key);
                    obj.quantity += e.quantity || 0;
                    if (e.cuveIds) obj.cuveIds = obj.cuveIds.concat(e.cuveIds);
                });
            });
            return Array.from(map.values());
        }

        // Ajoute la fonction showMoveLinePopup
        window.showMoveLinePopup = function() {
            let html = `<div class='mb-2 font-bold'>Déplacer toutes les cuves d'une ligne vers une autre</div>`;
            html += `<label class='block mb-1'>Numéro de la ligne à compléter (destination)</label>`;
            html += `<input id='moveLineDestInput' type='number' min='1' max='14' class='w-full p-2 border rounded mb-3' placeholder='Ligne destination' />`;
            html += `<label class='block mb-1'>Numéro de la ligne à transférer (source)</label>`;
            html += `<input id='moveLineSourceInput' type='number' min='1' max='14' class='w-full p-2 border rounded mb-3' placeholder='Ligne source' />`;
            html += `<div id='moveLineClientSelectContainer'></div>`;
            html += `<button id='moveLineDoBtn' class='bg-blue-500 hover:bg-blue-600 text-white font-bold px-4 py-2 rounded w-full' disabled>Déplacer</button>`;
            html += `<div id='moveLineActions'></div>`;
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-md w-full mx-4 relative'>
                <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(\".fixed\").remove()'>&times;</button>
                ${html}
            </div>`;
            document.body.appendChild(popupDiv);
            const destInput = popupDiv.querySelector('#moveLineDestInput');
            const sourceInput = popupDiv.querySelector('#moveLineSourceInput');
            const doBtn = popupDiv.querySelector('#moveLineDoBtn');
            const actionsDiv = popupDiv.querySelector('#moveLineActions');
            const clientSelectContainer = popupDiv.querySelector('#moveLineClientSelectContainer');
            let selectedClientCode = null;

            function updateClientSelect() {
                clientSelectContainer.innerHTML = '';
                selectedClientCode = null;
                const src = parseInt(sourceInput.value);
                if (!(src >= 1 && src <= 14)) return;
                // Cherche tous les clients présents sur la ligne source
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(src));
                const uniqueClients = Array.from(new Set(entries.map(e => e.clientCode)));
                if (uniqueClients.length > 1) {
                    // Plusieurs clients, afficher un menu déroulant
                    let selectHtml = `<label class='block mb-1'>Choisir le client à déplacer</label>`;
                    selectHtml += `<select id='moveLineClientSelect' class='w-full p-2 border rounded mb-3'>`;
                    selectHtml += `<option value=''>-- Sélectionner un client --</option>`;
                    uniqueClients.forEach(code => {
                        const name = entries.find(e => e.clientCode === code)?.clientName || code;
                        selectHtml += `<option value='${code}'>${code} - ${name}</option>`;
                    });
                    selectHtml += `</select>`;
                    clientSelectContainer.innerHTML = selectHtml;
                    const select = clientSelectContainer.querySelector('#moveLineClientSelect');
                    select.onchange = function() {
                        selectedClientCode = select.value || null;
                        updateDoBtn();
                    };
                } else if (uniqueClients.length === 1) {
                    // Un seul client, pas besoin de menu
                    selectedClientCode = uniqueClients[0];
                }
            }

            function updateDoBtn() {
                const dest = parseInt(destInput.value);
                const src = parseInt(sourceInput.value);
                let enable = (dest >= 1 && dest <= 14 && src >= 1 && src <= 14 && dest !== src);
                // Si plusieurs clients, il faut un client sélectionné
                const entries = stockEntries.filter(e => e.lines && e.lines.includes(src));
                const uniqueClients = Array.from(new Set(entries.map(e => e.clientCode)));
                if (uniqueClients.length > 1 && !selectedClientCode) enable = false;
                doBtn.disabled = !enable;
                actionsDiv.innerHTML = '';
            }
            destInput.oninput = function() { updateDoBtn(); };
            sourceInput.oninput = function() { updateClientSelect(); updateDoBtn(); };
            // Initialiser le menu client si la source est déjà remplie
            updateClientSelect();
            doBtn.onclick = function() {
                const dest = parseInt(destInput.value);
                const src = parseInt(sourceInput.value);
                if (!(dest >= 1 && dest <= 14 && src >= 1 && src <= 14 && dest !== src)) return;
                // Récupère les entrées à déplacer (filtrées par client si besoin)
                let entries = stockEntries.filter(e => e.lines && e.lines.includes(src));
                const uniqueClients = Array.from(new Set(entries.map(e => e.clientCode)));
                if (uniqueClients.length > 1 && selectedClientCode) {
                    entries = entries.filter(e => e.clientCode === selectedClientCode);
                }
                if (!entries.length) {
                    actionsDiv.innerHTML = `<div class='text-red-500'>Aucune cuve à transférer sur la ligne ${src}${selectedClientCode ? ' pour ce client' : ''}.</div>`;
                    return;
                }
                // Vérifie la capacité
                const totalQty = entries.reduce((sum, e) => sum + (e.quantity || 0), 0);
                const destInfo = getLineInfo(dest);
                if (destInfo.quantity + totalQty > 22) {
                    actionsDiv.innerHTML = `<div class='text-red-500'>Capacité insuffisante sur la ligne ${dest} (max 22 cuves).</div>`;
                    return;
                }
                // Transfère les cuves sélectionnées de src vers dest
                stockEntries.forEach(e => {
                    if (e.lines && e.lines.includes(src)) {
                        if (uniqueClients.length === 1 || (uniqueClients.length > 1 && e.clientCode === selectedClientCode)) {
                            e.lines = [dest];
                        }
                    }
                });
                updateStockViewAndSave();
                if (typeof generateLinesGrid === 'function') generateLinesGrid();
                document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                showPopup({
                    title: 'Déplacement effectué',
                    message: `Toutes les cuves de la ligne ${src}${selectedClientCode ? ' pour le client ' + selectedClientCode : ''} ont été déplacées vers la ligne ${dest}.`,
                    icon: '✅'
                });
            };
        };
        // ... existing code ...

        // === Ajout : Popup prélèvement cuve ===
        function showPrelevementCuvePopup() {
            let foundEntry = null, foundLine = null, foundClient = null, foundCuveId = null;
            let html = `<div class='mb-2 font-bold'>Numéro de cuve à prélever :</div>`;
            html += `<input id='prelevementCuveInput' type='text' class='w-full p-2 border rounded mb-3' placeholder='Numéro de cuve...' autocomplete='off' />`;
            html += `<div id='prelevementCuveResult' class='mb-3'></div>`;
            html += `<button id='prelevementCuveBtn' class='bg-pink-500 hover:bg-pink-600 text-white font-bold px-4 py-2 rounded' disabled>Transférer cuve dans prélèvement</button>`;
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-md w-full mx-4 relative'>
                <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(".fixed").remove()'>&times;</button>
                ${html}
            </div>`;
            document.body.appendChild(popupDiv);
            const input = popupDiv.querySelector('#prelevementCuveInput');
            const resultDiv = popupDiv.querySelector('#prelevementCuveResult');
            const btn = popupDiv.querySelector('#prelevementCuveBtn');
            input.oninput = function() {
                const val = input.value.trim().toLowerCase();
                foundEntry = null; foundLine = null; foundClient = null; foundCuveId = null;
                btn.disabled = true;
                resultDiv.innerHTML = '';
                if (!val) return;
                for (let l = 1; l <= 14; l++) {
                    const entries = stockEntries.filter(e => e.lines && e.lines.includes(l));
                    for (const e of entries) {
                        if (e.cuveIds && e.cuveIds.some(id => id && id.toLowerCase() === val)) {
                            foundEntry = e;
                            foundLine = l;
                            foundClient = e.clientName || e.clientCode;
                            foundCuveId = e.cuveIds.find(id => id && id.toLowerCase() === val);
                            break;
                        }
                    }
                    if (foundEntry) break;
                }
                if (foundEntry) {
                    resultDiv.innerHTML = `<div class='mb-2 text-sm'>Trouvé : <b>${foundCuveId}</b><br>Ligne : <b>${foundLine}</b><br>Client : <b>${foundClient}</b></div>`;
                    btn.disabled = false;
                } else {
                    resultDiv.innerHTML = `<div class='text-red-500 text-sm'>Aucune cuve trouvée</div>`;
                }
            };
            btn.onclick = function() {
                if (!foundEntry || !foundCuveId) return;
                // Retirer la cuve de l'entrée d'origine
                const idx = foundEntry.cuveIds.indexOf(foundCuveId);
                if (idx !== -1) {
                    foundEntry.cuveIds.splice(idx, 1);
                    foundEntry.quantity--;
                }
                if (foundEntry.quantity <= 0 || foundEntry.cuveIds.length === 0) {
                    const entryIdx = stockEntries.indexOf(foundEntry);
                    if (entryIdx !== -1) stockEntries.splice(entryIdx, 1);
                }
                // Ajouter la cuve dans prélèvement (ligne 0)
                stockEntries.push({
                    clientCode: foundEntry.clientCode,
                    clientName: foundEntry.clientName,
                    quantity: 1,
                    lines: [0],
                    cuveIds: [foundCuveId],
                    dateTime: foundEntry.dateTime,
                    user: foundEntry.user
                });
                if (typeof updateStockViewAndSave === 'function') updateStockViewAndSave();
                if (typeof updateLinesGrid === 'function') updateLinesGrid();
                document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                showPopup({
                    title: 'Transfert effectué',
                    message: 'La cuve a été transférée dans prélèvement.',
                    icon: '✅'
                });
            };
        }
        // ... existing code ...
        // Branche le clic sur la case prélèvement dans Stock
        // (dans updateStockView, après la création de prelevBtn)
        // ... SUPPRIMÉ: prelevBtn.onclick = showPrelevementCuvePopup;
        // Branche le clic sur la case prélèvement dans Ajouter
        // (dans generateLinesGrid, après la création de prelevBtn)
        // ... SUPPRIMÉ: prelevBtn.onclick = showPrelevementCuvePopup;
        // ... existing code ...

        // ... existing code ...
        function showDeleteClientPopup(mode) {
            // ... code du popup ...
        }
        window.showDeleteClientPopup = showDeleteClientPopup;
        // ... existing code ...

        // ... existing code ...
        function showDeleteClientPopup(mode) {
            // ... code du popup ...
        }
        window.showDeleteClientPopup = showDeleteClientPopup;
        // ... existing code ...

        // ... existing code ...
        function renderAisleSchema(lineNumber, cuveEntries) {
            // Trie les cuves par date/heure croissante (FIFO, fond -> devant)
            const sorted = cuveEntries.slice().sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));
            // Liste des clients dans la ligne (ordre d'apparition FIFO)
            const clientCodesInLine = Array.from(new Set(sorted.map(e => e.clientCode)));
            // Construction de la pile d'emplacements (1 à 11), chaque emplacement peut avoir plusieurs cuves (gerbées)
            let emplacements = Array.from({length: 11}, () => []);
            let cuveList = [];
            sorted.forEach(entry => {
                (entry.cuveIds || []).forEach((cuveId, idx) => {
                    cuveList.push({
                        cuveId,
                        client: entry.clientName || entry.clientCode,
                        clientCode: entry.clientCode,
                        dateTime: entry.dateTime,
                        entry
                    });
                });
            });
            // Répartit les cuves dans les emplacements (1 à 11), gerbage vertical
            let pos = 0;
            cuveList.forEach(cuve => {
                if (pos < 11) {
                    emplacements[pos].push(cuve);
                    pos++;
                } else {
                    // Si plus de 11 cuves, on gerbe à partir de l'emplacement 1, 2, ...
                    let gerbePos = (cuveList.indexOf(cuve)) % 11;
                    emplacements[gerbePos].push(cuve);
                }
            });
            let html = `<div class='flex flex-row gap-1 items-end mb-2'>`;
            for (let i = 0; i < 11; i++) {
                const pile = emplacements[i];
                // Couleur du client de la cuve du haut (accessible)
                const topClientCode = pile.length ? pile[pile.length-1].clientCode : null;
                const color = topClientCode ? getClientColor(topClientCode, clientCodesInLine) : '#e5e7eb';
                html += `<div class='flex flex-col items-center justify-end min-w-[38px]'>`;
                // Affiche la pile de cuves à cet emplacement (du bas vers le haut)
                if (pile.length) {
                    html += `<div class='w-10 h-10 rounded border flex flex-col items-center justify-center text-[10px] font-bold mb-1 overflow-hidden' style='max-width:40px; max-height:40px; white-space:nowrap; background:${color}; border-color:${color}; color:#fff;'>`;
                    pile.forEach((cuve, idx) => {
                        // ID cuve, gerbé si idx > 0
                        let label = cuve.cuveId;
                        if (idx > 0) label += 'g*';
                        html += `<div class='truncate w-full' title='${cuve.cuveId}'>${label}</div>`;
                    });
                    html += `</div>`;
                } else {
                    html += `<div class='w-10 h-10 rounded border border-gray-300 bg-gray-50'></div>`;
                }
                html += `<div class='text-xs text-gray-400'>${i + 1}</div>`;
                html += `</div>`;
            }
            html += `</div><div class='text-xs text-gray-500 mt-1'>g* = cuve gerbée</div>`;
            return html;
        }
        // ... existing code ...
        // Ajout du schéma d'allée dans la popup 'Compléter une ligne'
        function updateClientsSelect() {
            clientsContainer.innerHTML = '';
            selectedClients = [];
            clientsOrder = [];
            if (!(selectedSource >= 1 && selectedSource <= 14)) return;
            // Cherche tous les clients présents sur la ligne source, triés par date/heure croissante (FIFO, plus ancien en haut)
            const entries = stockEntries.filter(e => e.lines && e.lines.includes(selectedSource));
            // Trie par date/heure croissante (le plus ancien en haut, le plus récent en bas)
            const sorted = entries.slice().sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));
            clientsOrder = Array.from(new Set(sorted.map(e => e.clientCode)));
            // Schéma d'allée pour la ligne à vider
            clientsContainer.innerHTML += `<div class='mb-2'><b>Schéma de la ligne à vider (emplacements 1 à 11, fond → devant)</b></div>`;
            clientsContainer.innerHTML += renderAisleSchema(selectedSource, sorted);
            if (clientsOrder.length > 0) {
                let html = `<label class='block mb-1 mt-2'>Sélectionner le(s) client(s) à déplacer (ordre du plus ancien au plus récent)</label>`;
                html += `<div class='flex flex-col gap-1 mb-3'>`;
                clientsOrder.forEach((code, idx) => {
                    const name = entries.find(e => e.clientCode === code)?.clientName || code;
                    const color = getClientColor(code, clientsOrder);
                    html += `<label class='inline-flex items-center'><input type='checkbox' class='form-checkbox mr-2' value='${code}'><span style='color:${color}; font-weight:bold;'>${code} - ${name}</span></label>`;
                });
                html += `</div>`;
                clientsContainer.innerHTML += html;
                // Gestion de la sélection continue depuis le fond
                const checkboxes = Array.from(clientsContainer.querySelectorAll('input[type=checkbox]'));
                checkboxes.forEach((cb, idx) => {
                    cb.onchange = function() {
                        // Si on décoche un client, décocher tous ceux devant (plus récents)
                        if (!cb.checked) {
                            for (let i = idx + 1; i < checkboxes.length; i++) {
                                checkboxes[i].checked = false;
                            }
                        } else {
                            // Si on coche un client, cocher tous ceux au fond (plus anciens)
                            for (let i = 0; i < idx; i++) {
                                checkboxes[i].checked = true;
                            }
                        }
                        selectedClients = checkboxes.filter(c => c.checked).map(c => c.value);
                        updateDoBtn();
                    };
                });
            }
        }
        // ... existing code ...

        // ... existing code ...
        document.getElementById('truckLoadingFinishBtn').onclick = async function() {
            if (!window.truckLoadingData || !window.truckLoadingData.length) {
                await showPopup({
                    title: 'Erreur',
                    message: 'Aucun client sélectionné pour le chargement.',
                    icon: '⚠️'
                });
                return;
            }
            // Confirmation
            const confirmed = await showPopup({
                title: 'Confirmer le chargement',
                message: 'Voulez-vous supprimer toutes les cuves des clients sélectionnés du stock ?',
                icon: '🚚',
                confirmText: 'Oui, supprimer',
                cancelText: 'Annuler',
                showCancel: true
            });
            if (!confirmed) return;

            // Pour chaque client/date sélectionné, supprimer les cuves du stock
            window.truckLoadingData.forEach(item => {
                if (!item.clientCode || !item.dateTime) return;
                stockEntries = stockEntries.filter(e =>
                    !(e.clientCode === item.clientCode && e.dateTime === item.dateTime)
                );
            });

            // Vide la liste de chargement camion
            window.truckLoadingData = [];
            renderTruckLoadingList();

            // Met à jour l'affichage et sauvegarde
            updateStockViewAndSave();

            await showPopup({
                title: 'Succès',
                message: 'Les cuves des clients sélectionnés ont été supprimées du stock.',
                icon: '✅'
            });
        };
        // ... existing code ...

        // (2) Ajouter le bouton 'Supprimer toutes les cuves d'une ligne' dans l'onglet Stock
        if (stockTabContent && !document.getElementById('deleteLineBtn')) {
            const deleteLineBtn = document.createElement('button');
            deleteLineBtn.id = 'deleteLineBtn';
            deleteLineBtn.className = 'mb-4 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-bold text-base w-full';
            deleteLineBtn.innerText = "Supprimer toutes les cuves d'une ligne";
            stockTabContent.insertBefore(deleteLineBtn, stockTabContent.firstChild);
            deleteLineBtn.onclick = showDeleteLinePopup;
        }
        // ... existing code ...
        // (2) Fonction pour afficher le popup et supprimer les cuves d'une ligne
        async function showDeleteLinePopup() {
            // Cherche les lignes occupées
            const occupiedLines = [];
            const cuvesByLine = [];
            for (let l = 1; l <= 14; l++) {
                const info = getLineInfo(l);
                if (info.quantity > 0) {
                    occupiedLines.push({line: l, qty: info.quantity});
                    // Liste des cuves sur cette ligne
                    const entries = stockEntries.filter(e => e.lines && e.lines.includes(l));
                    const cuves = entries.flatMap(e => (e.cuveIds || []).map(id => ({id, entry: e})));
                    cuvesByLine.push({line: l, cuves});
                }
            }
            let html = `<div class='mb-2 font-bold'>Supprimer toutes les cuves d'une ligne</div>`;
            if (occupiedLines.length === 0) {
                html += `<div class='text-gray-500 mb-2'>Aucune ligne occupée.</div>`;
            } else {
                html += `<div class='mb-2'>Choisissez la ligne à supprimer :</div>`;
                html += `<div class='flex flex-wrap gap-2 mb-3'>`;
                occupiedLines.forEach(obj => {
                    html += `<button class='bg-red-100 hover:bg-red-200 text-red-700 font-bold px-4 py-2 rounded' data-line='${obj.line}'>Ligne ${obj.line} (${obj.qty} cuve${obj.qty>1?'s':''})</button>`;
                });
                html += `</div>`;
            }
            // Section suppression d'une cuve
            html += `<hr class='my-3'><div class='mb-2 font-bold'>Supprimer ou réaffecter une cuve</div>`;
            if (cuvesByLine.length === 0) {
                html += `<div class='text-gray-500 mb-2'>Aucune cuve à supprimer.</div>`;
            } else {
                cuvesByLine.forEach(obj => {
                    html += `<div class='mb-1'><b>Ligne ${obj.line} :</b> `;
                    if (obj.cuves.length === 0) {
                        html += `<span class='text-gray-400'>Aucune cuve</span>`;
                    } else {
                        obj.cuves.forEach(cuve => {
                            html += `<span class='inline-block bg-gray-100 border border-gray-300 rounded px-2 py-1 mx-1 my-1 cursor-pointer hover:bg-red-200' data-cuveid='${cuve.id}' data-line='${obj.line}'>${cuve.id} <span class='text-xs text-gray-500'>(${cuve.entry.clientName})</span></span>`;
                        });
                    }
                    html += `</div>`;
                });
            }
            const popupDiv = document.createElement('div');
            popupDiv.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
            popupDiv.innerHTML = `<div class='bg-white rounded-lg p-6 max-w-md w-full mx-4 relative'>
                <button class='absolute top-2 right-2 text-gray-400 hover:text-gray-700 text-2xl font-bold' onclick='this.closest(".fixed").remove()'>&times;</button>
                ${html}
                <div id='deleteLineConfirmContainer'></div>
            </div>`;
            document.body.appendChild(popupDiv);
            // Gestion du clic sur une ligne
            popupDiv.querySelectorAll('button[data-line]').forEach(btn => {
                btn.onclick = function() {
                    const line = parseInt(btn.dataset.line);
                    const confirmDiv = popupDiv.querySelector('#deleteLineConfirmContainer');
                    confirmDiv.innerHTML = `<div class='mb-2 text-red-700 font-bold'>Confirmer la suppression de toutes les cuves de la ligne ${line} ?</div>
                        <button class='bg-red-600 hover:bg-red-700 text-white font-bold px-4 py-2 rounded w-full mb-2' id='deleteLineConfirmBtn'>Supprimer</button>`;
                    popupDiv.querySelector('#deleteLineConfirmBtn').onclick = async function() {
                        // Suppression
                        stockEntries = stockEntries.filter(e => !(e.lines && e.lines.includes(line)));
                        updateStockViewAndSave();
                        if (typeof updateLinesGrid === 'function') updateLinesGrid();
                        document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                        showPopup({
                            title: 'Suppression effectuée',
                            message: `Toutes les cuves de la ligne ${line} ont été supprimées.`,
                            icon: '✅'
                        });
                    };
                };
            });
            // Gestion du clic sur une cuve
            popupDiv.querySelectorAll('span[data-cuveid]').forEach(span => {
                span.onclick = function() {
                    const cuveId = span.dataset.cuveid;
                    const line = parseInt(span.dataset.line);
                    const confirmDiv = popupDiv.querySelector('#deleteLineConfirmContainer');
                    confirmDiv.innerHTML = `<div class='mb-2 text-red-700 font-bold'>Que voulez-vous faire avec la cuve <b>${cuveId}</b> (ligne ${line}) ?</div>
                        <button class='bg-red-600 hover:bg-red-700 text-white font-bold px-4 py-2 rounded w-full mb-2' id='deleteCuveBtn'>Supprimer la cuve</button>
                        <button class='bg-blue-600 hover:bg-blue-700 text-white font-bold px-4 py-2 rounded w-full mb-2' id='changeClientBtn'>Changer de client</button>`;
                    popupDiv.querySelector('#deleteCuveBtn').onclick = async function() {
                        // Supprimer la cuve de l'entrée
                        let found = false;
                        for (const entry of stockEntries) {
                            if (entry.cuveIds && entry.cuveIds.includes(cuveId)) {
                                const idx = entry.cuveIds.indexOf(cuveId);
                                if (idx !== -1) {
                                    entry.cuveIds.splice(idx, 1);
                                    entry.quantity--;
                                    found = true;
                                }
                                if (entry.quantity <= 0 || entry.cuveIds.length === 0) {
                                    const entryIdx = stockEntries.indexOf(entry);
                                    if (entryIdx !== -1) stockEntries.splice(entryIdx, 1);
                                }
                                break;
                            }
                        }
                        updateStockViewAndSave();
                        if (typeof updateLinesGrid === 'function') updateLinesGrid();
                        document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                        showPopup({
                            title: 'Suppression effectuée',
                            message: `La cuve ${cuveId} a été supprimée de la ligne ${line}.`,
                            icon: '✅'
                        });
                    };
                    popupDiv.querySelector('#changeClientBtn').onclick = function() {
                        // Formulaire pour changer de client
                        confirmDiv.innerHTML = `<div class='mb-2 font-bold'>Changer le client de la cuve <b>${cuveId}</b> (ligne ${line})</div>
                            <input id='newClientInput' type='text' class='w-full p-2 border rounded mb-3' placeholder='Code ou nom client...' autocomplete='off' />
                            <button class='bg-blue-600 hover:bg-blue-700 text-white font-bold px-4 py-2 rounded w-full mb-2' id='confirmChangeClientBtn'>Valider</button>`;
                        const newClientInput = confirmDiv.querySelector('#newClientInput');
                        const confirmBtn = confirmDiv.querySelector('#confirmChangeClientBtn');
                        confirmBtn.onclick = function() {
                            const val = newClientInput.value.trim();
                            if (!val) return;
                            // Trouver le code et le nom du client
                            let code = val.split(' ')[0];
                            let name = val.substring(code.length).trim();
                            if (!name) {
                                // Si juste un code, chercher le nom dans la liste
                                name = clients[code] || code;
                            }
                            for (const entry of stockEntries) {
                                if (entry.cuveIds && entry.cuveIds.includes(cuveId)) {
                                    entry.clientCode = code;
                                    entry.clientName = name;
                                    break;
                                }
                            }
                            updateStockViewAndSave();
                            if (typeof updateLinesGrid === 'function') updateLinesGrid();
                            document.querySelectorAll('.fixed.inset-0').forEach(el => el.remove());
                            showPopup({
                                title: 'Changement effectué',
                                message: `La cuve ${cuveId} a été réaffectée à ${code} ${name}.`,
                                icon: '✅'
                            });
                        };
                    };
                };
            });
        }
        // ... existing code ...

        // Ajout du bouton 'Supprimer une ligne' dans Ajouter
        const addTabContent = document.getElementById('addTabContent');
        if (addTabContent && !document.getElementById('deleteLineBtnAdd')) {
            const deleteLineBtnAdd = document.createElement('button');
            deleteLineBtnAdd.id = 'deleteLineBtnAdd';
            deleteLineBtnAdd.className = 'mb-4 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-bold text-base w-full';
            deleteLineBtnAdd.innerText = "Supprimer toutes les cuves d'une ligne";
            addTabContent.insertBefore(deleteLineBtnAdd, addTabContent.firstChild);
            deleteLineBtnAdd.onclick = showDeleteLinePopup;
        }
        // (Le bouton existe déjà dans Stock sous l'id 'deleteLineBtn')
        // Fonction showDeleteLinePopup déjà présente, elle est utilisée pour les deux onglets
        // ... existing code ...

        // ... existing code ...
        
        // 2. Gestion de la persistance des clients
        function saveClientsToLocal() {
            try {
                localStorage.setItem('cuves_clients', JSON.stringify(clients));
            } catch(e) {}
        }
        function loadClientsFromLocal() {
            try {
                const data = localStorage.getItem('cuves_clients');
                if (data) {
                    const obj = JSON.parse(data);
                    if (typeof obj === 'object' && obj !== null) {
                        Object.keys(clients).forEach(k=>{if(!(k in obj)) obj[k]=clients[k];});
                        Object.assign(clients, obj);
                    }
                }
            } catch(e) {}
        }
        loadClientsFromLocal();
        // ... existing code ...

        // ... existing code ...
        // Ajout du formulaire d'ajout de client TOUT EN BAS de l'onglet Stock
        const stockTabContentAddClient = document.getElementById('stockTabContent');
        if (stockTabContentAddClient && !document.getElementById('addClientForm')) {
            const addClientDiv = document.createElement('div');
            addClientDiv.id = 'addClientForm';
            addClientDiv.className = 'mb-6 p-4 bg-blue-50 border border-blue-200 rounded flex flex-col gap-2 items-center';
            addClientDiv.innerHTML = `
                <div class='flex flex-col md:flex-row gap-2 w-full items-center'>
                    <input id='newClientCode' type='text' maxlength='10' placeholder='Code client' class='p-2 border rounded w-32' />
                    <input id='newClientName' type='text' maxlength='40' placeholder='Nom client' class='p-2 border rounded flex-1' />
                    <button id='addClientBtn' class='bg-blue-600 hover:bg-blue-700 text-white font-bold px-4 py-2 rounded'>Ajouter</button>
                    <span id='addClientMsg' class='text-sm ml-2'></span>
                </div>
            `;
            stockTabContentAddClient.appendChild(addClientDiv);
            document.getElementById('addClientBtn').onclick = async function() {
                const code = document.getElementById('newClientCode').value.trim();
                const name = document.getElementById('newClientName').value.trim();
                const msg = document.getElementById('addClientMsg');
                if (!code || !name) {
                    msg.textContent = 'Code et nom obligatoires';
                    msg.style.color = 'red';
                    return;
                }
                if (clients[code]) {
                    msg.textContent = 'Ce code existe déjà';
                    msg.style.color = 'red';
                    return;
                }
                const confirmed = await showPopup({
                    title: 'Confirmer l\'ajout',
                    message: `Ajouter le client : ${code} - ${name} ?`,
                    icon: '👤',
                    confirmText: 'Oui, ajouter',
                    cancelText: 'Annuler',
                    showCancel: true
                });
                if (!confirmed) return;
                clients[code] = name;
                saveClientsToLocal();
                msg.textContent = 'Client ajouté !';
                msg.style.color = 'green';
                document.getElementById('newClientCode').value = '';
                document.getElementById('newClientName').value = '';
                setTimeout(()=>{msg.textContent='';}, 2000);
                renderClientList();
            };
        }
        // Affichage de la liste des clients en colonnes de 12 max
        function renderClientList() {
            const listDiv = document.getElementById('clientList');
            if (!listDiv) return;
            const clientArr = Object.entries(clients);
            const cols = Math.ceil(clientArr.length / 12);
            let html = '<div class="flex flex-row flex-wrap gap-4">';
            for (let c = 0; c < cols; c++) {
                html += '<div class="flex flex-col gap-1">';
                for (let i = c * 12; i < Math.min((c + 1) * 12, clientArr.length); i++) {
                    const [code, name] = clientArr[i];
                    html += `<div class='flex items-center gap-2 mb-1'><span class='font-mono bg-gray-100 px-2 py-1 rounded'>${code}</span> <span>${name}</span> <button class='bg-red-500 hover:bg-red-700 text-white rounded px-2 py-1 text-xs' onclick='window.deleteClientFromList("${code}")'>Supprimer</button></div>`;
                }
                html += '</div>';
            }
            html += '</div>';
            listDiv.innerHTML = html;
        }
        // ... existing code ...
    </script>
</body>
</html>